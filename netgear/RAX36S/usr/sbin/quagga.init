#!/bin/sh
#
# quagga	Starts/stops quagga daemons and watchquagga.
#		Create a daemon.conf file to have that routing daemon
#		started/stopped automagically when using this script
#		without any daemon names as args.
#		If watchquagga is available, it will also be
#		started/stopped if the script is called without
#		any daemon names.
#

ME=$(basename $0)

usage() {
	echo "Usage: ${ME} {start|stop|restart} [daemon ...]"
	exit 2
}

if [ -z "$1" ]
then
	usage
else
	COMMAND=$1
fi
shift
ARG_DAEMONS=$*
BINDIR=/usr/sbin
CONFDIR=/etc/quagga
STATEDIR=/var/run/quagga
RUNUSER=root
RUNGROUP=$RUNUSER
DAEMONS="zebra ripd ripngd ospfd ospf6d bgpd"
DAEMON_FLAGS="-d -u $RUNUSER -g $RUNGROUP -A 127.0.0.1 -P 0"
WATCHQUAGGA_FLAGS="-d -z -T 60 -R"
WATCHQUAGGA_CMD="$0 watchrestart"
rip_version=`config get rip_version`
rip_direction=`config get rip_direction`
IPV6_TYPE=`config get ipv6_type`
IPV6_RIPNGD=`config get ipv6_ripng`

if [ "$rip_direction" = "1" ]; then
	RIPD_FLAGS="-o"
fi

if [ ${COMMAND} != "watchrestart" -a -x "${BINDIR}/watchquagga" ]
then
	DAEMONS="${DAEMONS} watchquagga"
fi
DAEMONS_STARTSEQ=${DAEMONS}

reverse()
{
	local revlist r
        revlist=
        for r
	do
                revlist="$r $revlist"
        done
        echo $revlist
}

DAEMONS_STOPSEQ=$(reverse ${DAEMONS_STARTSEQ})

#pidof() {
#	ps ax | awk 'match($5, "(^|/)'"$1"'$") > 0 { printf " %s", $1 }'
#}

quit() {
	echo "${ME}: $1"
	exit 0
}

die() {
	echo "${ME}: $1"
	exit 1
}

is_in() {
	local i
	for i in $2
	do
		[ "$1" = "$i" ] && return 0
	done
	return 1
}

select_subset() {
	local unknown i j
	unknown=
	RESULT=
	for i in $1
	do
		is_in $i "$2" || unknown="$unknown $i"
	done
	if [ -n "$unknown" ]
	then
		RESULT=$unknown
		return 1
	else
		for j in $2
		do
			is_in $j "$1" && RESULT="$RESULT $j"
		done
		return 0
	fi
}

print_ripd_conf()
{
	wan_proto=`config get wan_proto`
	case "$wan_proto" in
		"pppoe" | "pptp" | "l2tp")
			wan_ifname=ppp0
			;;
		"dhcp" | "static")
			wan_ifname=brwan
			;;
		*)
			wan_ifname=brwan
			;;
	esac
	
cat <<EOF
!
router rip
network $(config get lan_ifname)
network $wan_ifname
redistribute kernel
!
EOF
[ "$rip_version" = "1" ] && echo "version 1"
	# build  access-list
	num=1
	line=`config get static_router$num`
	static_routes=`cat /tmp/StaticRouteList`
	[ "X$static_routes" != "X" ] && echo "redistribute kernel route-map Ripd"
	while [ "X$line" != "X" ]
	do
		wanlan=`echo $static_routes | grep "$line"`
		if [ "X$wanlan" != "X" ]; then
			dest=$(echo $line | awk '{print $4}')
			echo "access-list $num permit $dest"
		fi
		num=$(($num+1))
		line=`config get static_router$num`
	done

	#set metric value
	num=1
	permit=10
	line=`config get static_router$num`
	static_routes=`cat /tmp/StaticRouteList`
	[ "X$static_routes" != "X" ] && echo "!"
	while [ "X$line" != "X" ]
	do
		wanlan=`echo $static_routes | grep "$line"`
		if [ "X$wanlan" != "X" ]; then
			metric=$(echo $line | awk '{print $7}')
			echo "route-map Ripd permit $permit"
			echo "match ip address $num"
			echo "set metric $metric"
			echo "!"
		fi
		num=$(($num+1))
		permit=$(($permit+1))
		line=`config get static_router$num`
	done

	#config  RIP Authentication
	auth_mode=`config get rip_auth_mode`
	if [ "$rip_version" != "1" ]; then
		if [ "$auth_mode" != "0" -a "$auth_mode" != "" ]; then
			if [ "$auth_mode" = "2" ]; then # md5 mode
				mode="md5"
				key_string=`config get rip_key_string`
			else
				mode="text"
				key_string=`config get rip_password`
			fi
			echo "key chain authstring" 
			echo "key 1" 
			echo "key-string $key_string"
			echo "!"
			echo "interface $(config get lan_ifname)"
			echo "ip rip authentication key-chain authstring"
			echo "ip rip authentication mode $mode"
			echo "!"
			echo "key chain authstring" 
			echo "key 1" 
			echo "key-string $key_string"
			echo "!"
			echo "interface $wan_ifname"
			echo "ip rip authentication key-chain authstring"
			echo "ip rip authentication mode $mode"
			echo "!"
		fi
	fi

	#config DNI Rip Direction 
	if [ "$rip_direction" = "1" ]; then  # in only
		echo "access-list list1 deny any"
		echo "access-list list2 permit any"
		echo "router rip"
		echo "distribute-list list1 out $(config get lan_ifname)"
		echo "distribute-list list2 in $(config get lan_ifname)"
		echo "distribute-list list1 out $wan_ifname"
		echo "distribute-list list2 in $wan_ifname"
		echo "!"
	fi

	if [ "$rip_direction" = "2" ]; then  # out only
		echo "access-list list1 deny any"
		echo "access-list list2 permit any"
		echo "router rip"
		echo "distribute-list list2 out $(config get lan_ifname)"
		echo "distribute-list list1 in $(config get lan_ifname)"
		echo "distribute-list list2 out $wan_ifname"
		echo "distribute-list list1 in $wan_ifname"
		echo "!"
	fi
}

print_ringd_conf() {
	local wanif
	local ip6_en_ripng=
	local lanif=$(config get lan_ifname)
	local ipv6_type=$(config get ipv6_type)
	if [ "$ipv6_type" = "autoDetect" ]; then
		ipv6_type=`cat /tmp/ipv6_auto_output`
		case "$ipv6_type" in
			"6to4 Tunnel")
				ipv6_type=6to4
				;;
			"6rd Tunnel")
				ipv6_type=6rd
				;;
			"DHCP")
				ipv6_type=dhcp
				;;
			"Auto Config")
				ipv6_type=autoConfig
				;;
			*)
				;;
		esac
	fi

	case $ipv6_type in
		dhcp | fixed | autoConfig)
			wanif=$(config get wan_ifname)
			;;
		6to4)
			wanif=sit1
			;;
		6rd)
			wanif=6rd
			;;
		pppoe)
			local ppp_same_login=$(config get ipv6_sameinfo)
			if [ $ppp_same_login -eq 1 ]; then
				wanif=ppp0
			else
				wanif=ppp2
			fi
			;;
		*)
			wanif=$(config get wan_ifname)
			ip6_en_ripng="!"
			;;
	esac

	if [ "$(config get ipv6_ripng)" != "1" ]; then
		ip6_en_ripng="!"
	fi

	cat > $CONFDIR/ripngd.conf <<-EOF
	! -*- rip -*-
	!
	! RIPngd configuration file
	! 
	! hostname netgear
	! password zebra
	!
	$ip6_en_ripng router ripng
	!
	network lo
	network $lanif
	network $wanif
	!
	route ::/0
	!
	! network sit1
	! route 3ffe:506::0/32
	! distribute-list local-only out sit1
	!
	!ipv6 access-list local-only permit 3ffe:506::0/32
	!ipv6 access-list local-only deny any
	!
	log stdout
	EOF
}

# check command

case ${COMMAND}
in
	start|stop|restart)
		;;
	watchrestart)
		if [ -n "$ARG_DAEMONS" ]
		then
			echo "${ME}: watchrestart mode is only for use by watchquagga"
			exit 2
		fi
		;;
	*)
		usage
		;;
esac

# select daemons to start

case ${COMMAND}
in
	start|restart|watchrestart)
		START_DAEMONS=
		for d in ${DAEMONS_STARTSEQ}
		do
			[ -x "${BINDIR}/${d}" -a -f "${CONFDIR}/${d}.conf" ] \
			&& START_DAEMONS="${START_DAEMONS}${d} "
		done
		START_DAEMONS="${START_DAEMONS} ripd"
		WATCHQUAGGA_DAEMONS=${START_DAEMONS}
		if is_in watchquagga "${DAEMONS_STARTSEQ}"
		then
			START_DAEMONS="${START_DAEMONS} watchquagga"
		fi
		if [ -n "${ARG_DAEMONS}" ]
		then
			if select_subset "${ARG_DAEMONS}" "${DAEMONS}"
			then
				if select_subset "${ARG_DAEMONS}" "${START_DAEMONS}"
				then
						START_DAEMONS="zebra $RESULT"
				else
					die "these daemons are not startable:${RESULT}."
				fi
			else
				die "unknown daemons:${RESULT}; choose from: ${DAEMONS}."
			fi
		fi
		;;
esac

# select daemons to stop

case ${COMMAND}
in
	stop|restart|watchrestart)
		STOP_DAEMONS=${DAEMONS_STOPSEQ}
		if [ -n "${ARG_DAEMONS}" ]
		then
			if select_subset "${ARG_DAEMONS}" "${STOP_DAEMONS}"
			then
				if [ "$rip_version" = "0" ] && [ "$IPV6_TYPE" = "disabled" -o "$IPV6_TYPE" = "bridge" -o "$IPV6_RIPNGD" = "0" ]; then
					STOP_DAEMONS="zebra $RESULT"
				else
					STOP_DAEMONS=${RESULT}
				fi
			else
				die "unknown daemons:${RESULT}; choose from: ${DAEMONS}."
			fi
		fi
		stop_daemons=
		for d in ${STOP_DAEMONS}
		do
			pidfile=${STATEDIR}/${d}.pid
			if [ -f "${pidfile}" -o -n "$(pidof ${d})" ]
			then
				stop_daemons="${stop_daemons}${d} "
			elif [ -n "${ARG_DAEMONS}" ]
			then
				echo "${ME}: found no ${d} process running."
			fi
		done
		STOP_DAEMONS=${stop_daemons}
		;;
esac

# stop daemons

for d in $STOP_DAEMONS
do
	echo -n "${ME}: Stopping ${d} ... "
	pidfile=${STATEDIR}/${d}.pid
	if [ -f "${pidfile}" ]
	then
		file_pid=$(cat ${pidfile})
		if [ -z "${file_pid}" ]
		then
			echo -n "no pid file entry found ... "
		fi
	else
		file_pid=
		echo -n "no pid file found ... "
	fi
	proc_pid=$(pidof ${d})
	if [ -z "${proc_pid}" ]
	then
		echo -n "found no ${d} process running ... "
	else
		count=0
		notinpidfile=
		for p in ${proc_pid}
		do
			count=$((${count}+1))
			if kill ${p}
			then
				echo -n "killed ${p} ... "
			else
				echo -n "failed to kill ${p} ... "
			fi
			[ "${p}" = "${file_pid}" ] \
			|| notinpidfile="${notinpidfile} ${p}"
		done
		[ ${count} -le 1 ] \
		|| echo -n "WARNING: ${count} ${d} processes were found running ... "
		for n in ${notinpidfile}
		do
			echo -n "WARNING: process ${n} was not in pid file ... "
		done
	fi
	count=0
	survivors=$(pidof ${d})
	while [ -n "${survivors}" ]
	do
		sleep 1
		count=$((${count}+1))
		survivors=$(pidof ${d})
		[ -z "${survivors}" -o ${count} -gt 5 ] && break
		for p in ${survivors}
		do
			sleep 1
			echo -n "${p} "
			kill ${p}
		done
	done
	survivors=$(pidof ${d})
	[ -n "${survivors}" ] && \
	if kill -KILL ${survivors}
	then
		echo -n "KILLed ${survivors} ... "
	else
		echo -n "failed to KILL ${survivors} ... "
	fi
	[ -n "$survivors" ] && sleep 1
	survivors=$(pidof ${d})
	if [ -z "${survivors}" ]
	then
		echo -n "done."
		if [ -f "${pidfile}" ]
		then
			rm -f ${pidfile} \
			|| echo -n " Failed to remove pidfile."
		fi
	else
		echo -n "failed to stop ${survivors} - giving up."
		if [ "${survivors}" != "${file_pid}" ]
		then
			if echo "${survivors}" > ${pidfile}
			then
				chown ${RUNUSER}:${RUNGROUP} ${pidfile}
				echo -n " Wrote ${survivors} to pidfile."
			else
				echo -n " Failed to write ${survivors} to pidfile."
			fi
		fi
	fi
	echo
done

# start daemons

if [ -n "$START_DAEMONS" ]
then
	[ -d ${CONFDIR} ] \
	|| quit "${ME}: no config directory ${CONFDIR} - exiting."
	chown -R ${RUNUSER}:${RUNGROUP} ${CONFDIR}
	[ -d ${STATEDIR} ] || mkdir -p ${STATEDIR} \
	|| die "${ME}: could not create state directory ${STATEDIR} - exiting."
	chown -R ${RUNUSER}:${RUNGROUP} ${STATEDIR}

	cat /dev/null > $CONFDIR/ripd.conf
	if [ "$rip_version" != "0" ]; then
		print_ripd_conf > $CONFDIR/ripd.conf
	fi

	print_ringd_conf

	for d in $START_DAEMONS
	do
		echo -n "${ME}: Starting ${d} ... "
		proc_pid=$(pidof ${d})
		pidfile=${STATEDIR}/${d}.pid
		file_pid=
		if [ -f "${pidfile}" ]
		then
			file_pid=$(cat ${pidfile})
			if [ -n "${file_pid}" ]
			then
				echo -n "found old pid file entry ${file_pid} ... "
			fi
		fi
		if [ -n "${proc_pid}" ]
		then
			echo -n "found ${d} running (${proc_pid}) - skipping ${d}."
			if [ "${proc_pid}" != "${file_pid}" ]
			then
				if echo "${proc_pid}" > ${pidfile}
				then
					chown ${RUNUSER}:${RUNGROUP} ${pidfile}
					echo -n " Wrote ${proc_pid} to pidfile."
				else
					echo -n " Failed to write ${proc_pid} to pidfile."
				fi
			fi
		elif rm -f "${pidfile}"
		then
			if [ "${d}" = "watchquagga" ]
			then
				"${BINDIR}/${d}" \
					${WATCHQUAGGA_FLAGS} \
					"${WATCHQUAGGA_CMD}" \
					${WATCHQUAGGA_DAEMONS}
				status=$?
			else
				if [ "${d}" = "ripd" -a "$rip_version" != "0" ]; then
					[ "$rip_version" = "2" ] && "/usr/bin/${d}" ${DAEMON_FLAGS} -B ${RIPD_FLAGS} || "/usr/bin/${d}" ${DAEMON_FLAGS} ${RIPD_FLAGS} 
				elif [ "${d}" = "zebra" ]; then
					if [ "$rip_version" != "0" ] || [ "$IPV6_TYPE" != "disabled" -a "$IPV6_TYPE" != "bridge" -a "$IPV6_RIPNGD" != "0" ]; then
						"${BINDIR}/${d}" ${DAEMON_FLAGS}
					fi
				else
					"${BINDIR}/${d}" ${DAEMON_FLAGS}
				fi
				status=$?
			fi
			if [ $status -eq 0 ]
			then
				echo -n "done."
			else
				echo -n "failed."
			fi
		else
			echo -n " failed to remove pidfile."
		fi
		echo
	done
fi

#! /bin/sh

TMP_UMOUNT_TABLE=/tmp/umounting_table_fgd456
TMP_DEVICE_NAME=/tmp/mounting_divice_name
TMP_DATA_XYZ=/tmp/proc_partition_dev
DISK_FIND_TABLE=/tmp/find_disk_abcxzy
UPDATE_NAME=/tmp/update_name

USB_DBG_FILE="usbdisk_hotplug.log"
ACTID_DATE="$(date +"%H%M%S")"
ACTID_RANDOM="$(head -10 /dev/urandom | md5sum | cut -c1-5)"
ACTID="${ACTID_DATE}_${ACTID_RANDOM}"
USB_MODULE="USB:UMOUNT"
USB_DGB_FLAG=/tmp/usbdbg_enable

usb_dbglog() {
    local dbg_message="$1"
	
	usbdbg_log "$USB_DBG_FILE" "[$USB_MODULE][ACTID:$ACTID] $dbg_message" 1>/dev/console 2>&1
}

echo_console() {
	local dbg_message="$1"

	echo "[$USB_MODULE][ACTID:$ACTID] $dbg_message" 1>/dev/console 2>&1
}

usb_dbglog_and_console() {
    local dbg_message="$1"

	if [ ! -f $USB_DGB_FLAG ]; then
		echo_console "$dbg_message"
	fi

	usb_dbglog "$dbg_message"
}

GUI_UMOUNT_RESULT=/tmp/umount_result
HOTPLUG_UMOUNT_RESULT=/tmp/umount_result_by_hotplug
update_umount_result() {
	local result_status="$1"
	local is_exit="$2"
	local result_outfile="$GUI_UMOUNT_RESULT"

	if [ "$safely_remove_act" = "0" ]; then
		result_outfile="$HOTPLUG_UMOUNT_RESULT"
	else
		result_outfile="$GUI_UMOUNT_RESULT"
	fi

	usb_dbglog "update_umount_result: result_status:$result_status, is_exit:$is_exit, safely_remove_act:$safely_remove_act, result_outfile:$result_outfile;"

	if [ "$result_status" = "success" ]; then
		echo "0" > $result_outfile
	elif [ "$result_status" = "fail" ]; then
		echo "1" > $result_outfile
	elif [ "$result_status" = "init" ]; then
		echo "" > $result_outfile
	fi

	if [ "$is_exit" = "exit" ]; then
		exit 1
	else
		return
	fi
}

dev_inproc(){
	rm -f $TMP_DATA_XYZ
	cat /proc/partitions | awk '{print $4}' | grep sd >$TMP_DATA_XYZ
	while read LINE
	do
		dev=`basename "$1"`
		if [ "$LINE" = "$dev" ];then
			return 0
			break
		fi
	done<$TMP_DATA_XYZ
	return 1
}

# $1--->umounting dir
isdafake(){
	
	mount | awk '{print $1}' | grep ^/dev/sd | cut -c 6->$TMP_DEVICE_NAME
	divnam=`echo "$1" | awk -F/ '{print $NF}'`
	sleep 1
	while read LINE
	do
		if [ "$LINE" = "$divnam" ];then
			return 1
			break
		fi
	done<$TMP_DEVICE_NAME
	return 0
}

get_vendor_from_disk()
{
	dev=`echo "$1" | cut -c 1-3`
	vendor=`cat /sys/block/$dev/device/vendor`
	model=`cat /sys/block/$dev/device/model`

	vendor=$(echo ${vendor} | sed 's/[[:space:]]*$//')
	model=$(echo ${model} | sed 's/[[:space:]]*$//')

	device_vendor="$vendor $model"
	device_vendor=`echo $device_vendor | sed 's/[[:space:]]*$//'`
	echo "$device_vendor"
}

get_volume_from_disk()
{
	disk_name=`echo $1 | sed 's/[0-9]//g'`
	partition_num=`echo $1 | cut -c 4-`
	volume=`/usr/sbin/vol_id -L /dev/$1`
	if [ "x$volume" = "x" ];then
		volume=`/usr/sbin/blkid $1 -s LABEL |awk -F'LABEL=' '{print $2}' |awk -F'"' '{print $2}'`
	fi
	if [ "x$volume" = "x" ];then
		volume=`echo $(/usr/sbin/parted -s /dev/$disk_name print | grep "Number" -A16 | sed -n '2,16p' | awk 'NF>=6{for(n=6;n<=NF;n++)printf $n" ";print     ""}' | sed -n $partition_num"p")`
		if [ "x$volume" = "x" ];then
			volume="$1"
		fi
	fi
	echo "$volume"
}

# $---> sda1
print_log()
{
        if [ `expr length $1` != '4' ];then
		 return
        fi

	sata_disk_name=`/bin/config get sata_diskname`

        device_name=`cat $DISK_FIND_TABLE | grep $1 | awk -F* '{print $2}'`
	[ "x$device_name" = "x" ] && device_name=`get_vendor_from_disk "$1"`
	volume_name=`cat $DISK_FIND_TABLE | grep $1 | awk -F* '{{{i=NF-3; a="*";while(i!=0) {printf $(NF-i); if(i!=1) printf a; i--}}}}'`
	[ "x$volume_name" = "x" ] && volume_name=`get_volume_from_disk "$1"`

	if [ "x$device_name" = "x" -a "x$volume_name" = "x" ]; then
		return
	fi
	if [ "x$sata_disk_name" = "x$1" ]; then
		logger "[External disk detached] The External disk $deivce_name($volume_name) is removed from the router"
		return
	else
		logger "[USB device detached] The USB device $device_name($volume_name) is removed from router"
		return
	fi

	volume_name=`/usr/sbin/blkid /dev/$1 | grep -o 'LABEL=.*' | awk -F\" '{print $2}'`
	if [ ! -n "$volume_name" ]; then
	       volume_name=$1
	fi
	logger "[USB device detached] The USB storage device $1($volume_name) is removed from the router"
	return
}


# $1--->upper dir (/tmp/mnt or /tmp/ftpgust/shares)
umount_all()
{
	umount_flag=0

	sync
	sync
	
	update_umount_result "init" "none"

	upper_dir="$1"

	usb_dbglog "umount_all for upper_dir:$upper_dir, start"
	
	cd $upper_dir
	if [ $? -ne 0 ]; then
		usb_dbglog "failure to cd into upper_dir:$upper_dir, finish and return"
		return
	fi
	
	for i in * ; do
		usb_dbglog "umount dir $upper_dir/$i, start"
		if [ "$i" = "*" ];then
			# if there are no sub folders in the cur folder,"i" var would be '*',
			# and ignore it and jump over
			usb_dbglog "skip umount dir $upper_dir/$i, finish"
			continue
		fi

		c=0
		while [ $c -le 3 ]; do
			usb_dbglog "try to umount dir $upper_dir/$i, retry count:$c"
			#/usr/sbin/detach_afp_shares
			sync
			umount $upper_dir/"$i"
			if [ $? -eq 0 ]; then
				[ $upper_dir = "/tmp/mnt" ] && print_log $1
				usb_dbglog "umount dir $upper_dir/$i success"
				break;
			fi
			let c=$c+1
		done
		umount_path="$upper_dir/$i"
		if [ $c -eq 4 ]; then
			usb_dbglog "umount dir $upper_dir/$i failure with retry count:$c"
			if dev_inproc "$umount_path"
			then
				usb_dbglog "dev $i with dir $upper_dir/$i still in /proc/partitions"
				usb_dbglog "umount dir $upper_dir/$i failure and continue"
				umount_flag=1
				continue
			else
				usb_dbglog "dev $i with dir $upper_dir/$i already not in /proc/partitions"
				usb_dbglog "try to umount dir $upper_dir/$i with force mode -f"
				umount "$upper_dir" -f
				if [ $? -eq 0 ]; then
					[ $upper_dir = "/tmp/mnt" ] && print_log $1
					usb_dbglog "umount dir $upper_dir/$i with force mode -f success"
				else
					usb_dbglog "umount dir $upper_dir/$i with force mode -f failure"
				fi
			fi
		fi
		rmdir "$i"
		usb_dbglog "umount dir $upper_dir/$i, finish"
	done	
	# when there are NOT any disks, we should set 0 to /tmp/umount_result
	if [ "x$(/bin/df | grep sd)" != "x"  -a $umount_flag -eq 1 ]; then
		usb_dbglog "umount_all for upper_dir:$upper_dir failure, finish and exit"
		update_umount_result "fail" "exit"
	else
		update_umount_result "success" "none"
		ledcontrol -n sata -c green -s off
		ledcontrol -n usb1 -c green -s off
		ledcontrol -n usb3 -c green -s off
	fi
	usb_dbglog "umount_all for upper_dir:$upper_dir, finish"
}

umount_part()
{
 # call from hotplug2
	
	sync
	sync

	update_umount_result "init" "none"
	
	umount_dir="$1"

	usb_dbglog "umount_part for umount_dir:$umount_dir, start"

	if isdafake "$umount_dir"
	then
		usb_dbglog "umount_dir:$umount_dir is isdafake"
		usb_dbglog "umount_part for umount_dir:$umount_dir, finish and return"
		return
	fi

	c=0
	while [ $c -le 3 ]; do
		usb_dbglog "try to umount_dir:$umount_dir, retry count:$c"
		#sync
		#/usr/sbin/detach_afp_shares "$umount_dir"
		sync
		if [ "$safely_remove_act" = "0" ]; then
			fuser -mk "$umount_dir"
		fi
		umount "$umount_dir"
		if [ $? -eq 0 ];then
			usb_dbglog "umount_dir:$umount_dir success"
			break
		fi
		let c=$c+1
	done
	if [ $c -eq 4 ]; then
		usb_dbglog "umount_dir:$umount_dir failure with retry count:$c"
		# only when disk is also in /proc/partition file,
		# in other words,the disk is not unpluged ,exit directly
		if dev_inproc "$umount_dir"
		then
			usb_dbglog "dev with dir $umount_dir is still in /proc/partitions"
			usb_dbglog "umount_part for umount_dir:$umount_dir failure, finish and exit!!!"
			update_umount_result "fail" "exit"
		else
			usb_dbglog "dev with dir $umount_dir is already not in /proc/partitions"
			usb_dbglog "try to umount dir $umount_dir with force mode -f"
			umount "$umount_dir" -f
			if [ $? -eq 0 ]; then
				usb_dbglog "umount dir $umount_dir with force mode -f success"
			else
				usb_dbglog "umount dir $umount_dir with force mode -f failure"
			fi
		fi
	fi
	rmdir "$umount_dir"
	if [ $? -ne 0 ];then
		usb_dbglog "umount dir $umount_dir failure, retry again"
		if [ "$safely_remove_act" = "0" ]; then
			# kill some possible tasks who is accessing usb disk to block umount command
			#/etc/init.d/samba stop; FIXME: commented by ASL
			usb_dbglog "Kill Minidlna Service"
			kill -9 `pidof minidlna`
			sleep 1
			#usb_dbglog "Stop AFP Service for umount dir $umount_dir"
			#/usr/sbin/detach_afp_shares "$umount_dir"
			sync
			usb_dbglog "fuser -mk, umount, rmdir for umount dir $umount_dir"
			fuser -mk "$umount_dir"
			umount "$umount_dir"
			rmdir "$umount_dir"
		fi
	fi
	usb_dbglog "umount_part for umount_dir:$umount_dir, finish"
}

umount_onepart_ftp()
{
 # call from hotplug2
	#RESULT=/tmp/umount_result
	
	#sync
	#sync

	#rm -f $RESULT
	
	umount_dir="$1"

	usb_dbglog "umount_onepart_ftp for umount_dir:$umount_dir, start"

	c=0
	while [ $c -le 3 ]; do
		usb_dbglog "try to umount_dir:$umount_dir, retry count:$c"
		#sync
		#/usr/sbin/detach_afp_shares "$umount_dir"
		#sync
		if [ "$safely_remove_act" = "0" ]; then
			fuser -mk "$umount_dir"
		fi
		umount "$umount_dir"
		if [ $? -eq 0 ];then
			usb_dbglog "umount_dir:$umount_dir success"
			break
		fi
		let c=$c+1
	done
	if [ $c -eq 4 ]; then
		usb_dbglog "umount_dir:$umount_dir failure with retry count:$c"
		# only when disk is also in /proc/partition file,
		# in other words,the disk is not unpluged ,exit directly
		if dev_inproc "$umount_dir"
		then
			usb_dbglog "dev with dir $umount_dir is still in /proc/partitions"
			usb_dbglog "umount_onepart_ftp for umount_dir:$umount_dir failure, finish and return!!!"
			#echo 1 > $RESULT
			#exit 1
			return
		else
			usb_dbglog "try to umount dir $umount_dir with force mode -f"
			umount "$umount_dir" -f
		fi
	fi
	rmdir "$umount_dir"
#	if [ $? -ne 0 ];then
#			usb_dbglog "umount dir $umount_dir failure, retry again"
#			# kill some possible tasks who is accessing usb disk to block umount command
#			#/etc/init.d/samba stop; FIXME: commented by ASL
#			#usb_dbglog "Kill Minidlna Service"
#			#kill -9 `pidof minidlna`
#			#sleep 1
#			#usb_dbglog "Stop AFP Service for umount dir $umount_dir"
#			#/usr/sbin/detach_afp_shares "$umount_dir"
#			#sync
#			usb_dbglog "fuser -mk, umount, rmdir for umount dir $umount_dir"
#			fuser -mk "$umount_dir"
#			umount "$umount_dir"
#			rmdir "$umount_dir"
#	fi
	usb_dbglog "umount_onepart_ftp for umount_dir:$umount_dir, finish"
}

check_umount_disk_led()
{
	# USB disk
	disk_name=`echo $1 | sed 's/[0-9]//g'`
	ls -l /sys/block | grep sd | awk '{print $9}' > /tmp/disk_rm
	while read LINE
	do
		#cd /sys/block/sda; ls -l
		#../../devices/platform/ipq-dwc3.0/dwc3.0/xhci-hcd.0/usb1/1-1/1-1:1.0/host4/target4:0:0/4:0:0:0
		#../../devices/platform/ipq-dwc3.1/dwc3.1/xhci-hcd.1/usb3/4-1/4-1:1.0/host3/target3:0:0/3:0:0:0
		# To get usb1 or usb3
		#usb_port=$(ls -l /sys/block/$LINE | grep usb | awk '{print $11}' | awk -F/ '{print $8}')
		#usb_name=`echo $usb_port | sed 's/[0-9]//g'`
		#usb_num=`echo $usb_port | cut -c 4-`
		if [ "x$LINE" = "x$disk_name" ]; then
			usb_interface=$(ls -l /sys/block/$LINE | grep usb | awk '{print $11}' | awk -F/ '{print $6}')
			if [ "x$usb_interface" != "x" ]; then
				if [ "$usb_interface" = "dwc3.0" ]; then
					ledcontrol -n usb1 -c green -s off
				elif [ "$usb_interface" = "dwc3.1" ]; then
					ledcontrol -n usb3 -c green -s off
				fi
			fi
		fi
	done</tmp/disk_rm
	rm /tmp/disk_rm

	#eSATA disk.
	sata_disk_name=`/bin/config get sata_diskname`
	if [ "x$sata_disk_name" = "x$disk_name" ]; then
		ledcontrol -n sata -c green -s off
	fi

}

# $1--->device name(sda1 or sdb3 or sdc3)
# $2--->upper dir for ftp(ftpadmin or ftpguest)
umount_part_ftp()
{
	devnam=$1
	up_dir=$2
	
	mount | grep "^\/dev\/$devnam\>" | awk '{print $3}' | grep "^\/var\/tmp\/$up_dir" | sed -e 's/\\040/ /g'>$TMP_UMOUNT_TABLE
	while read LINE
	do
		umount_onepart_ftp "$LINE"
	done<$TMP_UMOUNT_TABLE
}

ftp_down_upload()
{
	usb_dbglog "FTP down upload status check, start"
       LOAD=/tmp/ftp_load
       rm $LOAD
       ftp_load=0
       /usr/sbin/ftpload
       if [ -f $LOAD ]; then
		ftp_load=`cat $LOAD`
		if [ $ftp_load -gt 0 ]; then
			usb_dbglog "FTP status check result is busy, exit!!!!"
			update_umount_result "fail" "exit"
		fi	
       fi
	usb_dbglog "FTP down upload status check, finish"
}

service_stop()
{
	killall minidlna
	killall -9 smbd
}

safely_remove_act=1

usb_dbglog "USB UNMOUNT EVENT START"
usb_dbglog "SCRIPT:$0, ARG Cnt:$#, ARG List:$*;"

if [ $# -ge 2 ]; then
	if [ "$2" = "hotplug2" ]; then
		safely_remove_act=0
	fi
fi

update_umount_result "init" "none"

#service_stop
usb_dbglog_and_console "USB disk unmount, wait ..."
/sbin/usb_disk_event

if [ $# -eq 0 ]; then
	usb_dbglog_and_console "############ umount all start..."
#	echo "Stop greendownload..." > /dev/console
#	green_download.sh stop
	ftp_down_upload
	umount_all "/tmp/ftpadmin/shares"
#	umount_all "/tmp/ftpguest/shares"
	umount_all "/mnt"
#	logger "[USB device detached] ALL USB storage device is removed from the router"
	usb_dbglog "############ umount all finish..."
else
	usb_dbglog_and_console "############# umount disk $1 start"
#	echo "Detect if need to stop greendownload..." > /dev/console
#	green_download.sh stop $1
	ftp_down_upload
	umount_part_ftp "$1" "ftpadmin"
#	umount_part_ftp "$1" "ftpguest"
	umount_part "/mnt/$1"
	sleep 2
	check_umount_disk_led $1
	print_log $1
	usb_dbglog "############# umount disk $1 finish"
fi

#echo `date` stop smbd at hotplug2.umount >> /tmp/debug_smb
#/usr/sbin/update_smb
#killall -9 afpd
#/usr/sbin/update_afp
#/sbin/cmdftp start
#/sbin/cmddlna start
# in order to run this after run update_smb, moved it here
update_umount_result "success" "none"

#df |grep sd |awk '{print $1}' |cut -c 6- >$UPDATE_NAME
#while read LINE
#do
#	#update_smb $LINE
#	sleep 1
#done<$UPDATE_NAME

orig_min_free_kbytes=2853
if [ `cat /proc/sys/vm/min_free_kbytes` -ne $orig_min_free_kbytes -a "x`mount | grep sd`" == "x" ];then
	sysctl -w vm.min_free_kbytes=$orig_min_free_kbytes
fi

usb_dbglog "USB UNMOUNT EVENT FINISH"

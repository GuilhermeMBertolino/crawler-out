#!/usr/bin/lua

-- 
-- new_client_access_report.lua
-- [in]     upload_client_mac
-- 

local nixio = require "nixio"
local uci = require "luci.model.uci"
local json  = require "luci.json"
local dbg = require "luci.tools.debug"
local tm_client_mgmt = require "luci.model.tm_clientmgmt"  
local sys   = require "luci.sys"
local ubus  = require "ubus"
local uuid  = require "luci.model.uuid"
local _ubus = ubus.connect()

local RULE_TRIGGER = 4
local APP = 1
local UBUS_OBJECT = "cloud_client"
local NETWORK_NAME = "TP-Link"
local NETWORK_NAME_GUEST = "TP-Link Guest"
local CATEGORY = "WIRELESSROUTER"
local MSGTYPE_NEW_DEVICE = "New Device Detected"


function add_new_client(str)
    local client_tmp = str
    for i, client in ipairs(client_tmp) do
        client = client_tmp[i]
        if client.mac == nil then
            return 0
        end
        
        local client_mac = client.mac:gsub(":", "-"):upper()
        --dbg.print("client_mac is " .. client_mac)
        --dbg.print("upload_list: " .. str)

        -- 1. generate message and push	to cloud
        --dbg.print("add_new_client: mac:" .. client.mac .. " name:" .. client.hostname)

        local cur_time = os.time()

        local message = {}
        message.mac = client_mac
        message.name = client.hostname
        message.type = client.type
        message.guest = client.guest
        --dbg.print("message: " .. json.encode(message))

        -- 1. push to cloud
        local re, _ = push_new_client(cur_time, message)
        if not re or re ~= 0 then
            dbg.print("push_new_client failed")
            --return "push_new_client failed."
        end

        -- 2. store to config
        message.timestamp = cur_time
        local msg_id = uuid.generate_time()
        --dbg.print("msg_id: " .. msg_id)
        message.id = msg_id
    end
    dbg.print("new client access report end")
    return res
end

function push_new_client(msg_time, msg)
    local client_name = nixio.bin.b64decode(msg.name)
    if not client_name then
        dbg.print("client name is invalid")
        return false, "client name is invalid"
    end

    local NEW_CLIENT_CONTENT = "%s joined the %s's network."

	local req = {}
	req.params = {}
	req.method = "push"
	req.params.timeToLive = 3600
	req.params.from = CATEGORY

	local cur_time = os.time()
	
	local data = {}
	-- TODO: msgId 4_<timestamp>_<mac>_<increment id>
	local id = 1
	local mac = TrimStr(sys.exec("getfirm MAC"))
	data.msgId = ("msgId_4_%d_%s_%d"):format(cur_time, mac, id)
	data.msgType = "NEW_DEVICE_JOINED"	
	data.time = os.date("%s", msg_time)
	data.localTime = os.date("%Y-%m-%d %H:%M:%S", cur_time)
	-- TODO: multi-language?
    
	if msg.guest == "GUEST" then
		data.networkname = NETWORK_NAME_GUEST
	else
		data.networkname = NETWORK_NAME
	end
    
	data.title = MSGTYPE_NEW_DEVICE

	data.content = NEW_CLIENT_CONTENT:format(client_name, data.networkname)
	data.mac = msg.mac
	data.type = msg.type
	data.deviceName = client_name
	req.params.data = data

	local re, data = send_request_sync(req, 5000, 1)

	-- connection error
	if re ~= 0 then return re end
	
	if data == nil then
		dbg.print("return data is nil.")
		return 
	end
	if data.error_code == 0 then
		-- push OK
	end

	return data.error_code
end

function TrimStr(str)    
    str = str or ""
	
	if str ~= "" then
		local tmpstr = string.gsub(str, "-", "") or ""
		str = string.match(tmpstr, "%w+") or ""
		str = string.upper(str) or ""
	end
	
    return str
end

function send_request_sync(req, timeout_ms, flag)
	local args = {}
	
	--dbg.print("req:",json.encode(req))
	args.cloud_request_string = json.encode(req)
	args.cloud_request_timeout_ms = timeout_ms
	args.cloud_request_flag = flag
	
	local ret = _ubus:call(UBUS_OBJECT, "send_request_sync", args)
	
	if ret == nil then
		return -1000
	end
	
	dbg.print("re:", ret.re)
	if ret.re == 0 then                     
		dbg.print(ret.response)             
	end	
	
	return ret.re, json.decode(ret.response)
end

function query_client_list(cause, clients)
    --dbg.printf("[query_client_info]data:  " .. json.encode(data))
    local result = {}
    local properties = {}
    
    if not cause or not clients or #clients == 0 then
        return result
    end

    --local access_list = tm_client_mgmt.get_access_client_list()
   
    local deviceMap = tm_client_mgmt.get_client_type_list()
    local client_type_list = {}
    for mac,val in pairs(deviceMap) do
        mac = mac:gsub("[:-]", ""):upper()
        client_type_list[mac] = val
    end

    -- get hostname and alias, type
    local client_list = {}
    local uci_c = uci.cursor() 
    uci_c:foreach("history_list", "list",
        function(section)
            local mac = section.mac:gsub("[:-]", ""):upper()
            local client = {}
            client.mac = mac
            client.hostname = uci_c:get("history_list", section[".name"], "hostname")     
            client.hostname = nixio.bin.b64encode(client.hostname)
            client.type = tm_client_mgmt.get_client_type(mac, client_type_list)
            client_list[mac] = client
        end
    )
    
    for _, client in ipairs(clients) do
        local client_info = client_list[client.clientMac]
        if client_info then
            properties = client_info
        else
            properties = {}
        end
        result[#result + 1] = properties                                       
    end
    return result
end

local function batch_upload_property_change_clients(module, cause, clients)
    -- TODO: Only for clientInfo now
    if module ~= "clientInfo" then
        dbg.print("Batch only for clientInfo now")
        return
    end

    if type(clients) == type("") or #clients == 0 then
        local info = clients
        clients = {}
        clients[#clients + 1] = info 
    end

    local pid = nixio.fork()
    if not cause then
        cause = APP
    end

    local clientList = {}
    if pid == 0 then
        clientList = query_client_list(cause, clients)
        if #clientList == 0 then
            dbg.print("No property changed need upload")
            os.exit(1)
        end
        add_new_client(clientList) 
        os.exit(1)
    end
end

local function new_client_access_report(upload_clients)
    local cause = RULE_TRIGGER
    dbg.print("new client access report begin")
    --dbg.printf("[New Client Access Report] ====> clients:" .. json.encode(upload_clients))
    --new_client_access_upload.upload_property_change_client("clientInfo", cause, upload_clients)
    batch_upload_property_change_clients("clientInfo", cause, upload_clients)
end


local function remove_new_access_clients(file_path)
    if file_path and nixio.fs.access(file_path) then
        os.remove(file_path)
    end
end

local function read_new_access_clients(file_path)
    local clients = {}

    if not file_path or not nixio.fs.access(file_path) then
        return nil
    end

    local fp = io.open(file_path, "r")
    if not fp then
        return nil
    end
    for line in fp:lines() do
        --dbg.printf("[New Client Access Report] ====> MAC:" .. line:trim() .. " to upload")
        local client = {
          clientMac = line:trim():gsub("[:-]",""):upper(),
          new = true                           
        }
        clients[#clients + 1] = client
    end
    fp:close()    

    remove_new_access_clients(file_path)
    
    return clients
end

local function online_check()
    local sys = require "luci.sys"
    if sys.call("online-test") ~= 0 then
        return false
    else
        return true
    end
end

local function device_is_binded_check()
    local uci_r = uci.cursor()
    local bind_status = uci_r:get("cloud_config", "device_status", "bind_status") or "0"
    if bind_status == "1" then
        return true
    end
    return false
end

local function main()
    -- TODO: mv into client-mgmt?
    if not device_is_binded_check() then
        dbg.printf("[New Client Access Report] ====> Device is unbinded, ignore.")
        remove_new_access_clients(arg[1])
        return
    end
    -- Notice: rm new_clients file
    if not online_check() then
        dbg.printf("[New Client Access Report] ====> DUT is offline, ignore now.")
        remove_new_access_clients(arg[1])
        return
    end
    
    local client_list = read_new_access_clients(arg[1])    
    if client_list and #client_list > 0 then    
        new_client_access_report(client_list)        
    end    
end

main()

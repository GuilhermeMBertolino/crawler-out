#!/usr/bin/lua
--created by wanghao

local error = require "cloud_report.report_error"
local sys   = require "luci.sys"
local nixio = require "nixio"
local dbg   = require "luci.tools.debug"
local json = require "luci.json"
local io    = require "io"
local uci			= require "luci.model.uci"
local uci_r			= uci.cursor()

local content_type = "Content-type: application/json"
local url_postfix = "/v1/hardware"
local CLOUD_HOMECARE_TOKEN_FILE = "/tmp/cloud/cloud_token_homecare"
local CLOUD_SERVER_URL = "n-devs-gw.tplinkcloud.com"

local CLOUD_REPORT_MOD_ID = 231
local REPORT_BIND_SUCCESS = 51
local REPORT_BIND_FAILED = 201
local logm    = require "luci.model.log"
local log  = logm.Log(CLOUD_REPORT_MOD_ID)

local token
local origin_url
local fp
local retry = false
local retry_count = 0
local is_offline

local bind_status
local account_id

local function kill_process(cmd)
	local pid_info = io.popen("ps wwwww | grep " .. cmd .." | grep -v grep | awk '{print $1}'")
	local pid = 0
	if pid_info then
		while true do
			pid = pid_info:read("*l")
			if pid == nil then
				break
			end
			os.execute("kill -9 " .. pid)
		end
		pid_info:close()
	end
end

-- reduce duplication of call.
if arg[1] == "online" then
	-- bind and not register (call hardware success)
	bind_status = uci_r:get("cloud_config","device_status", "bind_status") or "0"
	local hardware = uci_r:get("avira","info", "hardware") or "no"
	if bind_status ~= "1" or hardware == "yes" then
		dbg.print("Do not start online bind upload!")
		return false
	end
end

-- online test
while true
do
	is_offline = sys.fork_call("dnslookup '%s'" % {CLOUD_SERVER_URL} )
	if is_offline == 0 then
		break
	else
		nixio.nanosleep(5, 0)
	end
end

while true
do
	-- check bind_status and account id each cycle, need to init uci every time, because the status may be changed
	uci_r = uci.cursor()
	bind_status = uci_r:get("cloud_config","device_status", "bind_status") or "0"
	account_id = uci_r:get("cloud_config","device_status", "accountid") or nil

	-- no account id or bind_status == 0, exit
	if bind_status == "0" or account_id == nil then
		break
	end

	retry = false

	if not nixio.fs.access(CLOUD_HOMECARE_TOKEN_FILE) then
		sys.call("cloud_getDevToken homecare")
	end

	if nixio.fs.access(CLOUD_HOMECARE_TOKEN_FILE) then
		fp = io.open(CLOUD_HOMECARE_TOKEN_FILE, "r")
		token = fp:read("*line")
		origin_url = fp:read("*line")..url_postfix
		fp:close()
	else
		-- try again when not get the homecare token
		sys.call("cloud_getDevToken homecare")
		if nixio.fs.access(CLOUD_HOMECARE_TOKEN_FILE) then
			fp = io.open(CLOUD_HOMECARE_TOKEN_FILE, "r")
			token = fp:read("*line")
			origin_url = fp:read("*line") .. url_postfix
			fp:close()
		else
			break
		end
	end

	local account = uci_r:get("cloud_config","device_status", "accountid") or ""
	local data = {
		["deviceId"] = string.match(sys.exec("getfirm DEV_ID"), "%w+"),
		["accountId"] = account
	}
	
	sys.call("echo `date` >/var/log/cloud_report_bind.result; echo '%s' >>/var/log/cloud_report_bind.result" % {json.encode(data)})
	dbg.print("[cloud-report][" .. arg[0] .. "][cloud_upload request]:", json.encode(data))
	
	local ret
	fp = io.popen("curl -S -l -H \"%s\" -H \"Authorization: %s\" -X POST -k -d \'%s\' --connect-timeout 8 %s --retry 3 --retry-delay 1 2>>/var/log/cloud_report_bind.result" % {content_type, token, json.encode(data), origin_url})
	if fp then
		ret = fp:read("*all")
		fp:close()
	end

	dbg.print("[cloud-report][" .. arg[0] .. "][cloud_upload response]:", ret)
	ret = json.decode(ret)

	if ret ~= nil then
		log(REPORT_BIND_FAILED, ret.code)
		if tonumber(ret.code) == error.ERROR_MSG.ERROR_INVALID_DEVICE_TOKEN[1] then
			--refresh token and upload again
			sys.call("rm " .. CLOUD_HOMECARE_TOKEN_FILE)
		end
		retry = true
		-- add sleep one minute, if retry over ten times, sleep one day
		if retry_count >= 10 then
			nixio.nanosleep(86400, 0)
		else
			nixio.nanosleep(60, 0)
		end
	else
		-- kill unbind script
		local unbind_script = "/usr/sbin/report_upload_unbind"
		kill_process(unbind_script)

		-- call hardware success, write to syslog and flash.
		log(REPORT_BIND_SUCCESS)
		uci_r:set("avira", "info", "hardware", "yes")
		uci_r:commit("avira")
		return true
	end

	if retry == false then
		break
	end

	retry_count = retry_count + 1
end

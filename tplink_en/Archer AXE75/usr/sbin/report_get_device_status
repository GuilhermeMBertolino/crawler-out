#!/usr/bin/lua

-- ### Get HomeShield pay status from cloud with interface "/v1/services/get-device-status"
-- ### And according to the result, change HomeShield running status.

local error = require "cloud_report.report_error"
local sys   = require "luci.sys"
local nixio = require "nixio"
local dbg   = require "luci.tools.debug"
local json  = require "luci.json"
local io	= require "io"
local uci			= require "luci.model.uci"
local uci_r			= uci.cursor()

local content_type = "Content-type: application/json"
local url_postfix = "/v1/services/get-device-status"
local CLOUD_HOMECARE_TOKEN_FILE = "/tmp/cloud/cloud_token_homecare"
local RUNNING_FLAG_FILE = "/tmp/report_get_device_status_is_running"
local CACERT_FILE = "/etc/certificate/2048_newroot.cer"
local LOG_FILE = "/var/log/homecarecloud_get_device_status.log"

math.randomseed(os.time()) 
local TP_AUC_UPDATE_TIME_INTERVAL_DEFAULT = 0
local TP_AUC_UPDATE_TIME_INTERVAL_FAST = math.random(1*60, 5*60) -- 第一次重试在1~5min内
local TP_AUC_UPDATE_TIME_INTERVAL_MAX = 24*60*60*7 -- 最大延时，每7天重试一次  

local retry_count = 0
local token
local origin_url
local fp
local i = 2
local ret
local ownerId
local errcode = -1
local device_id = string.match(sys.exec("getfirm DEV_ID"), "%w+")

local AVIRA_CONFIG_NAME = "avira"
local MAX_RETRY_COUNT = 3
local MAX_GLOBAL_RETRY_COUNT = 8
local tp_update_time_interval = TP_AUC_UPDATE_TIME_INTERVAL_DEFAULT

local info = debug.getinfo(1, "S") -- 第二个参数 "S" 表示仅返回 source,short_src等字段， 其他还可以 "n", "f", "I", "L"等 返回不同的字段信息
local path = info.source
path = string.sub(path, 2, -1) -- 去掉开头的"@"
local CRON_FILE="/etc/crontabs/root"
sys.fork_call("crontab -l | grep -v " .. path .. " | crontab -")

local function add_retry_time_interval()
	if tp_update_time_interval == TP_AUC_UPDATE_TIME_INTERVAL_DEFAULT then
		tp_update_time_interval = TP_AUC_UPDATE_TIME_INTERVAL_FAST
	elseif tp_update_time_interval < TP_AUC_UPDATE_TIME_INTERVAL_MAX  and (tp_update_time_interval * 2) < TP_AUC_UPDATE_TIME_INTERVAL_MAX then
		tp_update_time_interval = tp_update_time_interval * 2
	else
		tp_update_time_interval = TP_AUC_UPDATE_TIME_INTERVAL_MAX
	end
    dbg.print("tp_update_time_interval set to " .. tp_update_time_interval)
    return tp_update_time_interval
end

local function reset_retry_time_interval()
    dbg.print("tp_update_time_interval reset to default: " .. TP_AUC_UPDATE_TIME_INTERVAL_DEFAULT)
	tp_update_time_interval = TP_AUC_UPDATE_TIME_INTERVAL_DEFAULT
end


if nixio.fs.access(RUNNING_FLAG_FILE) then
	dbg.print("Another report_get_device_status is running!")
	return false
end

sys.fork_call("date | echo > '%s'" % {RUNNING_FLAG_FILE})

while(sys.call("online-test") ~= 0)
do
	os.execute("sleep 10")
	--dbg.print("[report_get_device_status] No internet connection... Recheck in 10s!")
end
local first_time_delay = math.random(1*60) + 1
dbg.print("[report_get_device_status] Internet connected... Wait for another " .. first_time_delay .. "s!")
os.execute("sleep " .. tostring(first_time_delay))

local global_retry_count = 0
while(errcode ~= 0)
do
	retry_count = 0
	i = 2
	while(retry_count < MAX_RETRY_COUNT)
	do
		retry_count = retry_count + 1

		if not nixio.fs.access(CLOUD_HOMECARE_TOKEN_FILE) then
			sys.fork_call("cloud_getDevToken homecare")
		end

		if nixio.fs.access(CLOUD_HOMECARE_TOKEN_FILE) then
			fp = io.open(CLOUD_HOMECARE_TOKEN_FILE, "r")
			token = fp:read("*line")
			origin_url = fp:read("*line")..url_postfix
			fp:close()
		else
			-- try again when not get the homecare token
			while (i > 0) do
				sys.fork_call("cloud_getDevToken homecare")
				if nixio.fs.access(CLOUD_HOMECARE_TOKEN_FILE) then
					fp = io.open(CLOUD_HOMECARE_TOKEN_FILE, "r")
					token = fp:read("*line")
					origin_url = fp:read("*line") .. url_postfix
					fp:close()
					break
				end
				i = i - 1
			end
		end

		if i ~= 0 then
			local data = {
				["deviceId"] = device_id
			}
			local data_str = json.encode(data)
			sys.fork_call("echo `date` >%s; echo '%s' >>%s" % {LOG_FILE, data_str, LOG_FILE})
			dbg.print("get-device-status form HomeCareCloud  request: ", data_str)

			fp = io.popen("curl -S -l -H \"%s\" -H \"Authorization: %s\" -X POST -d \'%s\' --cacert %s --connect-timeout 8 %s --retry 3 --retry-delay 1 2>>%s" % {content_type, token, data_str, CACERT_FILE, origin_url, LOG_FILE})

			if fp then
				ret = fp:read("*all")
				fp:close()
				sys.fork_call("echo '%s' >> %s" % {ret, LOG_FILE})
			end
			dbg.print("get-device-status form HomeCareCloud response:", ret)

			ret = json.decode(ret)
			if ret ~= nil then
				errcode = tonumber(ret.errorCode)
				if errcode == 0 then
					retry_count = MAX_RETRY_COUNT
				else
					if errcode == error.ERROR_MSG.ERROR_INVALID_DEVICE_TOKEN[1] then
						--refresh token and upload again
						os.remove(CLOUD_HOMECARE_TOKEN_FILE)
						os.execute("sleep 5")
					else
						retry_count = MAX_RETRY_COUNT
					end
				end
			end
		else
			dbg.print("can't get homecare token\n")
		end
	end
	if errcode ~= 0 then
		global_retry_count = global_retry_count + 1
		if global_retry_count ~= MAX_GLOBAL_RETRY_COUNT then
			os.execute("sleep " .. tostring(add_retry_time_interval()))
		end
	end
	if global_retry_count == MAX_GLOBAL_RETRY_COUNT then
		local nextQueryInterval = TP_AUC_UPDATE_TIME_INTERVAL_MAX
		local next_query_time = os.date("*t", os.time() + nextQueryInterval)
		local time_str = string.format('%d-%02d-%02d %02d:%02d:%02d', next_query_time.year, next_query_time.month, next_query_time.day, next_query_time.hour, next_query_time.min, next_query_time.sec)
		local crontab_str = string.format('%d %d %d %d %d %s', next_query_time.min, next_query_time.hour, next_query_time.day, next_query_time.month, next_query_time.year, path)
		dbg.print("Due to three consecutive request failures, Next Query time: " .. nextQueryInterval .. "s, corresponding time: " .. time_str .. ". Add Crontab: " .. crontab_str)
		sys.fork_call("echo -e \"" .. crontab_str .. "\" >> " .. CRON_FILE)
		os.remove(RUNNING_FLAG_FILE)
		return false
	end
end
-- change homeshield status according to result
-- API defined in https://yapi.rd.tp-link.net/project/182/interface/api/97402 (22/05/26)
if errcode == 0 then
	if ret.result ~= nil and ret.result.state ~= nil then
		local deviceId = ret.result.deviceId
		local deviceState = ret.result.state
		local aviraServiceStatus = ret.result.aviraServiceStatus
		local nextQueryInterval = ret.result.nextQueryInterval
		if deviceId ~= nil and deviceState ~= nil and deviceId == device_id and aviraServiceStatus ~= nil and nextQueryInterval ~= nil then
			local state
			local service
			local now_avira_status = uci_r:get("avira", "info", "status")
			local need_restart = true
			if aviraServiceStatus ~= "available" and aviraServiceStatus ~= "unavailable" and aviraServiceStatus ~= "libauc_available" and aviraServiceStatus ~= "safethings_available" then
				dbg.print("[Error] aviraServiceStatus field does NOT conform to the protocol! Value: " .. aviraServiceStatus .. ". Force set to available!!!!")
				need_restart = false
			elseif now_avira_status ~= aviraServiceStatus then
				-- uci_r:set("avira", "info", "status", aviraServiceStatus) -- 此处不设置uci，在aviraservice中set，因为aviraservice中会对比此uci值，提前set可能会导致aviraservice不启动
				-- uci_r:commit("avira")
			end
			deviceState = tonumber(deviceState)
			if deviceState == -1 then
				state = "free"
				service = "stop"
			elseif deviceState == 0 then -- paid but failed to get avira license
				state = "paid"
				service = "stop"
			elseif deviceState == 1 then
				state = "paid"
				service = "start"
			end
			
			local next_query_time = os.date("*t", os.time() + math.ceil((tonumber(nextQueryInterval)/1000)))
			local time_str = string.format('%d-%02d-%02d %02d:%02d:%02d', next_query_time.year, next_query_time.month, next_query_time.day, next_query_time.hour, next_query_time.min, next_query_time.sec)
			local crontab_str = string.format('%d %d %d %d %d %s', next_query_time.min, next_query_time.hour, next_query_time.day, next_query_time.month, next_query_time.year, path)
			dbg.print("Next Query time: " .. math.ceil((tonumber(nextQueryInterval)/1000)) .. "s, corresponding time: " .. time_str .. ". Add Crontab: " .. crontab_str)
			sys.fork_call("echo -e \"" .. crontab_str .. "\" >> " .. CRON_FILE)
			if need_restart then
				dbg.print("Run command: /usr/sbin/aviraservice update %s %s %s" % {state, service, aviraServiceStatus})
				sys.fork_call("/usr/sbin/aviraservice update %s %s %s" % {state, service, aviraServiceStatus})
			end
		end
	end
end

os.remove(RUNNING_FLAG_FILE)
return true

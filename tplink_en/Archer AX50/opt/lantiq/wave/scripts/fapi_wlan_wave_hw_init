#!/bin/sh
# Prepare Wave environment and initiate Wave drivers
# Needed object: Radio.Vendor

script_name="$0"

if [ -d /opt/lantiq ]
then
	vendor_name="lantiq"
elif [ -d /opt/intel ]
then
	vendor_name="intel"
else
	vendor_name="puma"
	if [ -e /nvram/wave_scripts ]
	then
		echo FOUND /nvram/wave_scripts/					!!!
		echo USING WAVE DEBUG SCRIPTS					!!!
		echo FOR ORIGINAL SCRIPTS PLEASE DELETE FOLDER	!!!
		mount -t tmpfs /tmp/scripts /etc/wave/scripts/
		cp /nvram/wave_scripts/* /etc/wave/scripts
	fi
fi

if [ -e /opt/${vendor_name}/wave/scripts/fapi_wlan_wave_lib_common.sh ]
then
	lib_common_path="/opt/${vendor_name}/wave/scripts/fapi_wlan_wave_lib_common.sh"
elif [ -e /etc/wave/scripts/fapi_wlan_wave_lib_common.sh ]
then
	lib_common_path="/etc/wave/scripts/fapi_wlan_wave_lib_common.sh"
fi
. $lib_common_path

#Debug FAPI helper tool symbolic link
if [ "$CONFIG_FEATURE_LTQ_WAVE_PRODUCT_MODE" = "1" ]; then
	echo "############### PRODUCT MODE ###############" > /dev/console
else
	echo "############### DEVELOPMENT MODE ###############" > /dev/console
	ln -s ${ETC_PATH}/fapi_wlan_wave_debug.sh ${USRSBINDIR}/fapiToolBox
	#Debug clish
	#mv /usr/bin/clish /usr/bin/clishApp
	#ln -s ${ETC_PATH}/fapi_wlan_wave_clish.sh ${USRSBINDIR}/clish
fi


# In case sigma exist create a symbolic links
if [ -e ${ETC_PATH}/sigma-start.sh ]; then
	ln -s ${ETC_PATH}/sigma-start.sh ${USRSBINDIR}/sigmas
	ln -s ${ETC_PATH}/sigma-ap.sh ${USRSBINDIR}/sigma-ap.sh
	ln -s ${ETC_PATH}/sigma-run.sh ${USRSBINDIR}/sigma-run.sh
fi

if [ ! -e "$FAPI_RPC" ]; then
	if [ $(ls -l  /overlay/opt/lantiq/wave/scripts/ | wc -l) -gt 0 ]; then
		echo "##### ATTENTION: ########################################" > $TRACE_OUT
		echo "##### ATTENTION: scripts in overlay                 #####" > $TRACE_OUT
		echo "##### ATTENTION: DISABLE fast boot delete conf/*    #####" > $TRACE_OUT
		echo "##### ATTENTION: ########################################" > $TRACE_OUT
	 [ -d ${CONF_DIR} ] && rm -rf ${CONF_DIR}
	fi
fi

mkdir -p $CONF_DIR
mkdir -p $TEMP_DIR

echo "##### WORKAROND: ##################### #####" > $TRACE_OUT
echo "##### WORKAROND: DISABLE eth_bond_init #####" > $TRACE_OUT
echo "##### WORKAROND: ##################### #####" > $TRACE_OUT
[ -e ./etc/init.d/eth_bond_init.sh ] && mv ./etc/init.d/eth_bond_init.sh ./etc/init.d/eth_bond_init.sh.workaround.dis_bond

## confs md5 check sum checking
if [ -e ${CONF_DIR}/md5confs.cs ]; then 
	cd ${CONF_DIR};	md5sum -c md5confs.cs > ${TEMP_DIR}/md5confs.log;md5confs_ret="$?";cd -
	echo -e "##### md5confs.cs exist md5confs_ret=$md5confs_ret #####" > $TRACE_OUT
else
	echo -e "##### md5confs.cs was not found #####" > $TRACE_OUT
fi

if [ ! -e ${USE_CURRENT_CONF}_wlan0 ] || [ ! -e ${USE_CURRENT_CONF}_wlan2 ] || [ "$md5confs_ret" != "0" ]; then
	rm -rf ${CONF_DIR}/*
	echo -e "##### remove conf files starting NORMAL BOOT #####\n" > $TRACE_OUT
else
	echo -e "##### FAST BOOT MODE #####\n" > $TRACE_OUT
fi

if [ -e ${USE_CURRENT_CONF}_wlan0 ]
then
	echo "####### $script_name: init flow with conf from previous setting - FAST BOOT" > $TRACE_OUT

	# When using existing conf files, use indexes used by internal DB
	radio0_vendor_index=`find_index_from_interface_name wlan0`
else
	# DEBUG: set debug_save_conf in fapi_wlan_wave_lib_common.sh to save the in conf file
	[ "$debug_save_conf" ] && cp ${IN_CONF} ${TEMP_DIR}/hw_init_in_conf

	# Save the input configuration parameters to a local DB used by Wave FAPI and source it
	if [ ! -e "$FAPI_RPC" ]; then
		wifi_index=`map_param_index Object $WIFI_OBJECT`
	else	
		wifi_index=`map_param_index Object $RADIO_VENDOR_OBJECT`
	fi

	[ -n "$wifi_index" ] && save_db_params hw_init all $wifi_index 0

	# Set flag indicating radio_set to remove the radio conf
	touch $REMOVE_RADIO_CONF

	# When using in.conf conf files, use indexes used by in.conf
	radio0_vendor_index=0
	radio1_vendor_index=1
	radio2_vendor_index=2
fi

local_db_source RADIO
local_db_source WIFI

timestamp $radio0_vendor_index "$script_name:begin"
print2log $radio0_vendor_index DEBUG "$script_name $*"

# Set the init flag to indicate init sequence is in progress
touch $INIT_FLAG

eeprom_partition=wlanconfig
eeprom_tar=eeprom.tar.gz

next_object_index=3

# driver_mode can be ap or dut
driver_mode=$1
[ -z "$driver_mode" ] && driver_mode="ap"

# Create softlinks for library functions
cp -s ${ETC_PATH}/fapi_wlan_wave_lib* /tmp/

# Delete the runner file
rm -f ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "[ ! \"\$LIB_COMMON_SOURCED\" ] && . $lib_common_path" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# Disable voltage scaling in PMCU
echo "$script_name: Disable voltage scaling in PMCU" > $TRACE_OUT
pm_util -x 0

[ -n "$CONFIG_IFX_CONFIG_CPU" ] && echo "$script_name CONFIG_IFX_CONFIG_CPU = $CONFIG_IFX_CONFIG_CPU" > $TRACE_OUT
[ -n "$CONFIG_IFX_MODEL_NAME" ] && echo "$script_name CONFIG_IFX_MODEL_NAME = $CONFIG_IFX_MODEL_NAME" > $TRACE_OUT

# Count number of physical WAVE interfaces
# Read information of physical Wlan interface from wlan_discover output
(. ${ETC_PATH}/fapi_wlan_wave_discover.sh)
. ${TEMP_DIR}/fapi_wlan_wave_discover.txt
wave_count=$((PCI_LTQ_COUNT+AHB_WLAN_COUNT))

chip_id_0=`check_wave_chip_id wlan0`
chip_id_2=`check_wave_chip_id wlan2`
chip_id_4=`check_wave_chip_id wlan4`

print2log $radio0_vendor_index ATTENTION "$script_name:###########################################"

print2log $radio0_vendor_index ATTENTION "$script_name:chipids: card0=$chip_id_0 card1=$chip_id_2 card2=$chip_id_4"

if [ -e ${USE_CURRENT_CONF}_wlan0 ]; then
	print2log $radio0_vendor_index ATTENTION "$script_name:#### init flow with conf from previous setting - FAST BOOT"
else
	print2log $radio0_vendor_index ATTENTION "$script_name:#### init flow NEW conf files"
fi
print2log $radio0_vendor_index ATTENTION "$script_name:###########################################"



if [ -e ${USE_CURRENT_CONF}_wlan0 ]
then
	build_wlan_notification "servd" "NOTIFY_WIFI_WLAN_HW_INIT_DONE" "NO_PARAMS" "runner"

	# Use the previously saved runner
	# Execute the runner
	$HW_INIT_RUNNER

	# Create the output configuration file
	cat /dev/null > ${OUT_CONF}

	# Use the previously saved out.conf
	cp ${HW_INIT_OUT_CONF} ${OUT_CONF}

	# Use fapi_wlan_wave_discover.txt from previous hw init
	cp ${CONF_DIR}/fapi_wlan_wave_discover.txt ${TEMP_DIR}/fapi_wlan_wave_discover.txt

	# DEBUG: set debug_save_conf in fapi_wlan_wave_lib_common.sh to save the out conf file
	[ "$debug_save_conf" ] && cp ${OUT_CONF} ${TEMP_DIR}/hw_init_out_conf

	print2log $radio0_vendor_index DEBUG "$script_name done"
	timestamp $radio0_vendor_index "$script_name:done"

	exit 0
fi

if [ ! -e "$FAPI_RPC" ]; then

	# If 1 PCI card and internal Wlan are detected, check if WaveUseSinglePCI is set
	# WaveUseSinglePCI is true when wish to work with 1 PCI card only (no internal Wlan)
	if [ $PCI_LTQ_COUNT -eq 1 ] && [ $AHB_WLAN_COUNT -eq 1 ]
	then
		use_single_pci=`db2fapi_convert boolean WaveUseSinglePCI 0`
		if [ "$use_single_pci" = "1" ]
		then
			AHB_WLAN_COUNT=0
			wave_count=$((wave_count-1))
			echo "AHB_DISABLED=1" >> ${TEMP_DIR}/fapi_wlan_wave_discover.txt
			print2log 0 ATTENTION "$script_name: WaveUseSinglePCI=1, internal Wlan is disabled"
		fi
	fi

	# If more than 2 Radio bands are detected and one of them is internal, check if the internal Wlan is disabled
	if [ $wave_count -gt 2 ] && [ "$AHB_WLAN_COUNT" = "1" ]
	then
		disable_ahb=`db2fapi_convert boolean WaveDisableAHB 0`
		# set AHB_WLAN_COUNT=0 and reduce wave_count if needed
		if [ "$disable_ahb" = "1" ]
		then
			AHB_WLAN_COUNT=0
			wave_count=$((wave_count-1))
			echo "AHB_DISABLED=1" >> ${TEMP_DIR}/fapi_wlan_wave_discover.txt
			print2log 0 ATTENTION "$script_name: 3 Radios detected, internal Wlan is disabled"
		else
			print2log 0 ATTENTION "$script_name: 3 Radios detected, internal Wlan is enabled"
			echo "AHB_DISABLED=0" >> ${TEMP_DIR}/fapi_wlan_wave_discover.txt
		fi
	fi
fi

# No Wave interfaces were found, print error, update DB Radio status of all radios to NotPresent and exit script.
if [ "$wave_count" = "0" ]
then
	print2log 0 ERROR "$script_name: No WAVE interfaces found"
	echo "$script_name: No WAVE interfaces found" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	rm -f $INIT_FLAG
	exit 1
fi

echo "cd /tmp" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# Create softlinks needed in /tmp
echo "cp -s ${DRIVER_PATH}/mtlkroot.ko /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "cp -s ${BINDIR}/fw_scd_file.scd /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "cp -s ${BINDIR}/hw_scd_file.scd /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "cp -s ${DRIVER_PATH}/mtlk.ko /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "cp -s ${IMAGES_PATH}/* /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "ln -sf ${CONF_DIR} /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER} #openWRT - For iwinfo to allocate hostapd's confs
[ -e "/lib/modules/3.10.104/compat.ko" ] && echo "cp -s /lib/modules/3.10.104/compat.ko /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
[ -e "/lib/modules/3.10.104/cfg80211.ko" ] && echo "cp -s /lib/modules/3.10.104/cfg80211.ko /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
[ -e "/lib/modules/3.10.104/mac80211.ko" ] && echo "cp -s /lib/modules/3.10.104/mac80211.ko /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
[ -e "/lib/modules/3.10.104/iwlwifi.ko" ] && echo "cp -s /lib/modules/3.10.104/iwlwifi.ko /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
[ -e "/lib/modules/3.10.104/iwlmvm.ko" ] && echo "cp -s /lib/modules/3.10.104/iwlmvm.ko /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# Yocto read-only workaround: override files if they exist in /nvram/etc/wave_overlay folder
echo "if [ -d /nvram/etc/wave_overlay ]" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "then" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "	for f in /nvram/etc/wave_overlay/*" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "	do" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "		echo \"NOTE:  Overriding  \${f#/nvram/etc/wave_overlay/}\" with file from wave_overlay" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "		cp -s \$f /tmp" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "	done" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "fi" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# Use the ls.txt file to load files to /tmp if the wave_wlan_debug_ls_txt.sh script exists.
[ -e "${ETC_PATH}/fapi_wlan_wave_debug_tftp_bins.sh" ] && (. ${ETC_PATH}/fapi_wlan_wave_debug_tftp_bins.sh)

# Configure Hotplug
echo "echo ${SBINDIR}/hotplug > /proc/sys/kernel/hotplug" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# Start udevd and call crda once, for triggering regulatory domain change notifications
# The crda calls should be done only once on the first init. Using flag to detect first init.
echo "udevd_running=\`is_process_running udevd\`" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "[ \$udevd_running -eq 1 ] || udevd --daemon" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
if [ ! -e $CRDA_FLAG ]
then
	echo "export COUNTRY=00" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	echo "crda" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	echo "touch $CRDA_FLAG" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
fi

# TEMPORARY: insmod IRE related drivers before Wave driver
[ -e "/lib/modules/3.10.104/compat.ko" ] && echo "insmod compat.ko" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
[ -e "/lib/modules/3.10.104/cfg80211.ko" ] && echo "insmod cfg80211.ko" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
[ -e "/lib/modules/3.10.104/mac80211.ko" ] && echo "insmod mac80211.ko" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# insmod rtlogoer
echo "insmod mtlkroot.ko" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# Set MAC address to the logger interface and add it to the bridge
# TODO: currently moved to the start sequence, needs to be moved back to init
#echo "ifconfig rtlog0 hw ether 00:00:00:00:00:00" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
# Read the bridge name from brctl
#bridge_name=`read_bridge_from_db rtlog0 $radio0_vendor_index`
#echo "brctl addif $bridge_name rtlog0" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
#echo "ifconfig rtlog0 up" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
# Create the logger streams
#i=0
#while [ $i -lt $wave_count ]
#do
#	(. $ETC_PATH/wave_wlan_logger_modify $i init)
#      i=$((i+1))
#done
# Load logserver (if exists)
if [ -e ${BINDIR}/logserver ]
then
	echo "cp -s ${BINDIR}/logserver /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	echo "/tmp/logserver -f /tmp/dev/mtlkroot0 -s /tmp/fw_scd_file.scd &" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
fi

# Get calibration file from FLASH only if file doesn't already exist in /tmp/
# Support Puma (/nvram/etc), Havenpark (/nvram) and UGW read_img
echo "if [ ! -e /tmp/cal_wlan0.bin ]" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "then" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
if [ -d /nvram/etc/wave_cal ]
then
	# Command to copy cal_wlan files for PUMA
	echo "	cp /nvram/etc/wave_cal/* /tmp/ 2>/dev/null" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
elif [ -d /nvram ]
then
	echo "	tar xzf /nvram/$eeprom_tar -C /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
else
	# Commands to get cal_wlan files from FLASH in UGW
	echo "	read_img $eeprom_partition /tmp/$eeprom_tar" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	echo "	tar xzf /tmp/$eeprom_tar -C /tmp/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	echo "	tar xzf /tmp/$eeprom_tar -C /lib/firmware/" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	echo "	cp /opt/${vendor_name}/wave/images/* /lib/firmware" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
fi
# TODO: add verification for calibration extract success.
echo "fi" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# Insmod WAVE driver
# fastpath enables/disables GSWIP usage. Needed only for GRX350.
fastpath_cmd=""
fastpath0=""
fastpath2=""
fastpath4=""
disable_fastpath0=""
disable_fastpath2=""
disable_fastpath4=""

# If platform is not GRX350, don't set fastpath command and disable fastpath for all interfaces
if [ "$CONFIG_IFX_CONFIG_CPU" != "GRX500" ] && [ "$CONFIG_IFX_CONFIG_CPU" != "GRX750" ] && [ ! -e "$FAPI_RPC" ]
then
	disable_fastpath0=1
	disable_fastpath2=1
	disable_fastpath4=1
else
	fastpath0=`db2fapi_convert boolean WaveFastpathEnabled $radio0_vendor_index`
	fastpath2=`db2fapi_convert boolean WaveFastpathEnabled $radio1_vendor_index`
	fastpath4=`db2fapi_convert boolean WaveFastpathEnabled $radio2_vendor_index`
	echo "Fast Path from DB:wlan0[$fastpath0] wlan2[$fastpath2] wlan4[$fastpath4]" >$TRACE_OUT

	# If AHB is enabled, wlan0 doesn't support fastpath
	[ "$AHB_WLAN_COUNT" = "1" ] && fastpath0=0 && disable_fastpath0=1

	fastpath_cmd="fastpath=${fastpath0},${fastpath2},${fastpath4}"

	if [ -e "$FAPI_RPC" ]; then
		fastpath_cmd=""
		[ "$wave_count" = "1" ] && fastpath_cmd="fastpath=${fastpath0}"
		[ "$wave_count" = "2" ] && fastpath_cmd="fastpath=${fastpath0},${fastpath2}"
		[ "$wave_count" = "3" ] && fastpath_cmd="fastpath=${fastpath0},${fastpath2},${fastpath4}"
	fi
fi

# If AHB is not used, set ahb_off flag
ahb_off_cmd=""
[ $AHB_WLAN_COUNT = 0 ] && ahb_off_cmd="ahb_off=1"
# Set the value for the driver_mode
#driver_mode_cmd="$driver_mode"
#driver_mode_cmd="$driver_mode_cmd=1,1,1"

# looger SID for insmod WAVE Driver
# gen5=127, gen6=255 ,Twin mountain=511.
logger_sid_command=""
loggerSID=`check_wave_logger_sid wlan0 $CONFIG_IFX_CONFIG_CPU`
logger_sid_param="$loggerSID"

if [ $wave_count -eq 2 ]
then
	loggerSID=`check_wave_logger_sid wlan2 $CONFIG_IFX_CONFIG_CPU`
	logger_sid_param="$logger_sid_param,$loggerSID"
fi

if [ $wave_count -eq 3 ] 
then
	loggerSID=`check_wave_logger_sid wlan4 $CONFIG_IFX_CONFIG_CPU`
	logger_sid_param="$logger_sid_param,$loggerSID"
fi

logger_sid_command="loggersid=$logger_sid_param"

bcl_mode=""
bcl_enable=`db2fapi_convert boolean WaveBclEnabled 0`
[ "$bcl_enable" = "1" ] && bcl_mode="bcl=1" || bcl_mode=""

dual_pci_enable=""
[ "$dual_pci_enable" = "" ] && dual_pci_enable=`db2fapi_convert regular WaveDualPciEnabled 0`
case "$dual_pci_enable" in
	"00")
		dual_pci="dual_pci=0,0"
	;;
	"01")
		dual_pci="dual_pci=0,1"
	;;
	"10")
		dual_pci="dual_pci=1,0"
	;;
	"11")
		dual_pci="dual_pci=1,1"
	;;
	*)
		print2log $radio0_vendor_index ATTENTION "$script_name:dual_pci param was not set"
	;;
esac

# Recovery FAPI SOCKET INIT
echo "[ -z "\$\(pgrep -x \$\{USRSBINDIR\}/fapi_wave_recoveryd\)" ] && \${USRSBINDIR}/fapi_wave_recoveryd &" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "rcvry_timeout=0" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "while [ -z "\$\(pgrep -x \$\{USRSBINDIR\}/fapi_wave_recoveryd\)" ] && [ \$rcvry_timeout -lt 15 ]" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "do" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "echo \"RCVRY:FAPI SOCKET INIT in progress wait \$rcvry_timeout of 15\" >>$TRACE_OUT" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "let rcvry_timeout=\$((rcvry_timeout+1))" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "done" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# Currently supporting only 2 cards.rcvry_on is set per card not per interface.
rcvry_on=""
cards_recovery_enable=""
[ "$cards_recovery_enable" = "" ] && cards_recovery_enable=`db2fapi_convert regular WaveRecoveryEnabled 0`
case "$cards_recovery_enable" in
	"00")
		if [ "$wave_count" = "1" ]; then
			rcvry_on="rcvry_on=0"
		else
			rcvry_on="rcvry_on=0,0"
		fi
	;;
	"01")
		if [ "$wave_count" = "1" ]; then
			rcvry_on="rcvry_on=1"
		else
			rcvry_on="rcvry_on=0,1"
		fi
	;;
	"10")
		rcvry_on="rcvry_on=1,0"
	;;
	"11")
		if [ "$wave_count" = "1" ]; then
			rcvry_on="rcvry_on=1"
		else
			rcvry_on="rcvry_on=1,1"
		fi
	;;
	*)
		print2log $radio0_vendor_index ATTENTION "$script_name:rcvry_on param:wlan_count=$wave_count cards_recovery was not set"
	;;
esac

##########################
##  insmod mtlk.ko      ##
##########################
print2log $radio0_vendor_index ATTENTION "$script_name:###################################################"
print2log $radio0_vendor_index ATTENTION "$script_name: insmod command: insmod mtlk.ko    $driver_mode_cmd $fastpath_cmd $ahb_off_cmd"
print2log $radio0_vendor_index ATTENTION "                                                  $logger_sid_command $bcl_mode $dual_pci $rcvry_on"
print2log $radio0_vendor_index ATTENTION "$script_name:####################################################"
echo "insmod mtlk.ko $driver_mode_cmd $fastpath_cmd $ahb_off_cmd $logger_sid_command $bcl_mode $dual_pci $rcvry_on" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# print driver release info.
echo "head -8 cat /proc/net/mtlk/version"  >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# save eeprom info.
echo "iw wlan0 iwlwav gEEPROM > ${CONF_DIR}/eeprom_info" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
## in case of AxePoint and dual lane setting:
## in case of daul lane on Conn#2 we will have 3 PCIs detected (2 on GPB cards ver.1822T) ,all other cases 2 PCIs detected (1 on GPB cards ver.1822T).
## GPB654 2 PCIs detected (dual lane config) on all GPB cards versions.
echo ". ${TEMP_DIR}/fapi_wlan_wave_discover.txt" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
echo "[ \$TOTAL_WLAN_COUNT -ge 2 ] && iw wlan2 iwlwav gEEPROM >> ${CONF_DIR}/eeprom_info" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# TEMPORARY: insmod WCS drivers after setting the GPIOs
[ -e "/lib/modules/3.10.104/iwlwifi.ko" ] && echo "insmod iwlwifi.ko" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
[ -e "/lib/modules/3.10.104/iwlmvm.ko" ] && echo "insmod iwlmvm.ko" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# TODO: add check for insmod success.
echo "cd - > /dev/null" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

# UGW WORKAROUND: remove wlan interfaces from udev rules (in Yocto this is handled at build time in 80-net-setup-link.rules)
if [ -e /etc/udev/rules.d/70-persistent-net.rules ]
then
	echo "grep -v wlan /etc/udev/rules.d/70-persistent-net.rules > ${CONF_DIR}/tmp_70-persistent-net.rules" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
	echo "mv ${CONF_DIR}/tmp_70-persistent-net.rules /etc/udev/rules.d/70-persistent-net.rules" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
fi

# If Gen4 exists, enable CPU queue 35 (for cases that the GEN4 radio is disabled)
[ "$AHB_WLAN_COUNT" = "1" ] && echo "iw wlan0 iwlwav sLtPathEnabled 1" >> ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

if [ ! -e $FAPI_RPC ]
then
build_wlan_notification "servd" "NOTIFY_WIFI_WLAN_HW_INIT_DONE" "NO_PARAMS" "runner"
fi

# Execute the runner and save it
chmod +x ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}
${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER}

cp ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER} $HW_INIT_RUNNER

# DEBUG: set debug_save_runner in fapi_wlan_wave_lib_common.sh to save the runner script
[ "$debug_save_runner" ] && cp ${CONF_DIR}/${FAPI_WLAN_WAVE_RUNNNER} ${CONF_DIR}/runner_hw_init.sh

# Create the output configuration file
cat /dev/null > ${OUT_CONF}

# Check for insmod success
mtlk_count=`lsmod | grep ^mtlk -c`

if [ $mtlk_count -ne 2 ]
then
	# Init is FAILURE
	update_conf_out "wlan_configuration_status" "FAILURE"
	exit 1
fi

# Create and read the conf file including the interfaces names and status
interfaces_order_conf=${TEMP_DIR}/interfaces_order.conf
ret=`init_check_interfaces_order $wave_count $interfaces_order_conf $radio0_vendor_index`
if [ $ret -ne 0 ]
then
	update_conf_out "wlan_configuration_status" "FAILURE"
	exit 1
fi
. $interfaces_order_conf

#TBD- check driver version if gen6 then TODO AHB disabble and reboot 
# PcieG6 for gen6
# PcieG5 for gen5
# Update parameters for 2.4GHz radio (if 2.4GHz radio exists)
##########################
## Object_0   wlanx     ##
##########################
if [ "$name_radio_24" != "EMPTY" ]
then
	update_conf_out "Object_0" "${RADIO_VENDOR_OBJECT}"
	[ "$disable_fastpath0" ] && update_conf_out "WaveFastpathEnabled_0" "false" && save_hw_init_out $name_radio_24 0 "WaveFastpathEnabled" "false"

	# Read number of antennas from driver
	driver_num_of_antennas=`get_driver_num_of_antennas $name_radio_24`

	# Set number of antennas, BF-ANTENNA and SOUNDING-DIMENSION from driver to XML
	num_antennas_db=`db2fapi_convert regular NumOfAntennas $radio0_vendor_index`
	bf_antenna_db=`db2fapi_convert regular VhtBfAntenna $radio0_vendor_index`
	sounding_dimension_db=`db2fapi_convert regular VhtSoundingDimension $radio0_vendor_index`
	if [ "$driver_num_of_antennas" ]
	then
		# Check if need to update DB with new values
		[ $driver_num_of_antennas -lt $num_antennas_db ] && antennas_to_set="$driver_num_of_antennas"
		[ $driver_num_of_antennas -lt $bf_antenna_db ] && vht_bf_antenna_to_set="$driver_num_of_antennas"
		[ $driver_num_of_antennas -lt $sounding_dimension_db ] && vht_sounding_to_set="$driver_num_of_antennas"

		[ -n "$antennas_to_set" ] && update_conf_out "NumOfAntennas_0" "$antennas_to_set" && save_hw_init_out $name_radio_24 0 "NumOfAntennas" "$antennas_to_set"
		[ -n "$vht_bf_antenna_to_set" ] && update_conf_out "VhtBfAntenna_0" "$vht_bf_antenna_to_set" && save_hw_init_out $name_radio_24 0 "VhtBfAntenna" "$vht_bf_antenna_to_set"
		[ -n "$vht_sounding_to_set" ] && update_conf_out "VhtSoundingDimension_0" "$vht_sounding_to_set" && save_hw_init_out $name_radio_24 0 "VhtSoundingDimension" "$vht_sounding_to_set"
	fi

	# Read driver capability for beamforming.
	# If driver doesn't support beamforming, set explicit beamforming, implicit beamforming and vht beamforming disabled
	beamforming_support=`iw $name_radio_24 iwlwav gBfExplicitCap`
	beamforming_support=`echo ${beamforming_support##*:}`
	if [ "$beamforming_support" = "0" ]
	then
		update_conf_out "WaveExplicitBeamforming_0" "false" && save_hw_init_out $name_radio_24 0 "WaveExplicitBeamforming" "false"
		update_conf_out "WaveImplicitBeamforming_0" "false" && save_hw_init_out $name_radio_24 0 "WaveImplicitBeamforming" "false"
		update_conf_out "VhtSUbeamformerEnabled_0" "false" && save_hw_init_out $name_radio_24 0 "VhtSUbeamformerEnabled" "false"
	fi

	## for gen6a & gen6b need to disable
	[ "$chip_id_0" = "$GEN6_CHIP_ID" ] && update_conf_out "VhtSTBCrxEnabled_0" "false" && save_hw_init_out $name_radio_24 0 "VhtSTBCrxEnabled" "false"

fi
# Update parameters for 5GHz radio (if 5GHz radio exists)
##########################
## Object_1   wlanx     ##
##########################
if [ "$name_radio_51" != "EMPTY" ]
then
	update_conf_out "Object_1" "${RADIO_VENDOR_OBJECT}"
	[ "$disable_fastpath2" ] && update_conf_out "WaveFastpathEnabled_1" "false" && save_hw_init_out $name_radio_51 2 "WaveFastpathEnabled" "false"

	# Read number of antennas from driver
	driver_num_of_antennas2=`get_driver_num_of_antennas $name_radio_51`

	# Set number of antennas, BF-ANTENNA and SOUNDING-DIMENSION from driver to XML
	num_antennas_db2=`db2fapi_convert regular NumOfAntennas $radio1_vendor_index`
	bf_antenna_db2=`db2fapi_convert regular VhtBfAntenna $radio1_vendor_index`
	sounding_dimension_db2=`db2fapi_convert regular VhtSoundingDimension $radio1_vendor_index`
	if [ "$driver_num_of_antennas2" ]
	then
		# Check if need to update DB with new values
		[ $driver_num_of_antennas2 -lt $num_antennas_db2 ] && antennas_to_set2="$driver_num_of_antennas2"
		[ $driver_num_of_antennas2 -lt $bf_antenna_db2 ] && vht_bf_antenna_to_set2="$driver_num_of_antennas2"
		[ $driver_num_of_antennas2 -lt $sounding_dimension_db2 ] && vht_sounding_to_set2="$driver_num_of_antennas2"

		[ -n "$antennas_to_set2" ] && update_conf_out "NumOfAntennas_1" "$antennas_to_set2" && save_hw_init_out $name_radio_51 2 "NumOfAntennas" "$antennas_to_set2"
		[ -n "$vht_bf_antenna_to_set2" ] && update_conf_out "VhtBfAntenna_1" "$vht_bf_antenna_to_set2" && save_hw_init_out $name_radio_51 2 "VhtBfAntenna" "$vht_bf_antenna_to_set2"
		[ -n "$vht_sounding_to_set2" ] && update_conf_out "VhtSoundingDimension_1" "$vht_sounding_to_set2" && save_hw_init_out $name_radio_51 2 "VhtSoundingDimension" "$vht_sounding_to_set2"
	fi

	# Read driver capability for beamforming.
	# If driver doesn't support beamforming, set explicit beamforming, implicit beamforming and vht beamforming disabled
	beamforming_support2=`iw $name_radio_51 iwlwav gBfExplicitCap`
	beamforming_support2=`echo ${beamforming_support2##*:}`
	if [ "$beamforming_support2" = "0" ]
	then
		update_conf_out "WaveExplicitBeamforming_1" "false" && save_hw_init_out $name_radio_51 2 "WaveExplicitBeamforming" "false"
		update_conf_out "WaveImplicitBeamforming_1" "false" && save_hw_init_out $name_radio_51 2 "WaveImplicitBeamforming" "false"
		update_conf_out "VhtSUbeamformerEnabled_1" "false" && save_hw_init_out $name_radio_51 2 "VhtSUbeamformerEnabled" "false"
	fi

	[ "$wave_count" = "1" ] && chipid_index=0 || chipid_index=2
	tmp_param="chip_id_$chipid_index"
	eval chip_id_val=\$$tmp_param

	[ "$chip_id_val" = "$GEN6_CHIP_ID" ] && update_conf_out "WaveMuOperation_1" "false" && save_hw_init_out $name_radio_51 2 "WaveMuOperation" "false"
	## for gen6a & gen6b need to disable
	[ "$chip_id_val" = "$GEN6_CHIP_ID" ] && update_conf_out "VhtSTBCrxEnabled_1" "false" && save_hw_init_out $name_radio_51 2 "VhtSTBCrxEnabled" "false"

fi

# Update parameters for the second 5GHz radio (if second 5GHz radio exists)
##########################
##  Object_2   wlanx    ##
##########################
if [ "$name_radio_52" != "EMPTY" ]
then
	update_conf_out "Object_2" "${RADIO_VENDOR_OBJECT}"
	[ "$disable_fastpath4" ] && update_conf_out "WaveFastpathEnabled_2" "false" && save_hw_init_out $name_radio_52 4 "WaveFastpathEnabled" "false"

	# Read number of antennas from driver
	driver_num_of_antennas4=`get_driver_num_of_antennas $name_radio_52`

	# Set number of antennas, BF-ANTENNA and SOUNDING-DIMENSION from driver to XML
	num_antennas_db4=`db2fapi_convert regular NumOfAntennas $radio2_vendor_index`
	bf_antenna_db4=`db2fapi_convert regular VhtBfAntenna $radio2_vendor_index`
	sounding_dimension_db4=`db2fapi_convert regular VhtSoundingDimension $radio2_vendor_index`
	if [ "$driver_num_of_antennas4" ]
	then
		# Check if need to update DB with new values
		[ $driver_num_of_antennas4 -lt $num_antennas_db4 ] && antennas_to_set4="$driver_num_of_antennas4"
		[ $driver_num_of_antennas4 -lt $bf_antenna_db4 ] && vht_bf_antenna_to_set4="$driver_num_of_antennas4"
		[ $driver_num_of_antennas4 -lt $sounding_dimension_db4 ] && vht_sounding_to_set4="$driver_num_of_antennas4"

		[ -n "$antennas_to_set4" ] && update_conf_out "NumOfAntennas_2" "$antennas_to_set4" && save_hw_init_out $name_radio_52 4 "NumOfAntennas" "$antennas_to_set4"
		[ -n "$vht_bf_antenna_to_set4" ] && update_conf_out "VhtBfAntenna_2" "$vht_bf_antenna_to_set4" && save_hw_init_out $name_radio_52 4 "VhtBfAntenna" "$vht_bf_antenna_to_set4"
		[ -n "$vht_sounding_to_set4" ] && update_conf_out "VhtSoundingDimension_2" "$vht_sounding_to_set4" && save_hw_init_out $name_radio_52 4 "VhtSoundingDimension" "$vht_sounding_to_set4"
	fi

	# Read driver capability for beamforming.
	# If driver doesn't support beamforming, set explicit beamforming, implicit beamforming and vht beamforming disabled
	beamforming_support4=`iw $name_radio_52 iwlwav gBfExplicitCap`
	beamforming_support4=`echo ${beamforming_support4##*:}`
	if [ "$beamforming_support4" = "0" ]
	then
		update_conf_out "WaveExplicitBeamforming_2" "false" && save_hw_init_out $name_radio_52 4 "WaveExplicitBeamforming" "false"
		update_conf_out "WaveImplicitBeamforming_2" "false" && save_hw_init_out $name_radio_52 4 "WaveImplicitBeamforming" "false"
		update_conf_out "VhtSUbeamformerEnabled_2" "false" && save_hw_init_out $name_radio_52 4 "VhtSUbeamformerEnabled" "false"
	fi

	[ "$chip_id_4" = "$GEN6_CHIP_ID" ] && update_conf_out "WaveMuOperation_2" "false" && save_hw_init_out $name_radio_52 4 "WaveMuOperation" "false"
	## for gen6a & gen6b need to disable
	[ "$chip_id_4" = "$GEN6_CHIP_ID" ] && update_conf_out "VhtSTBCrxEnabled_2" "false" && save_hw_init_out $name_radio_52 4 "VhtSTBCrxEnabled" "false"

fi

# Map indexes for the objects to return:
# wifi, radio for first interface
wifi_index=$next_object_index
next_object_index=$((next_object_index+1))
radio_index=$next_object_index
next_object_index=$((next_object_index+1))

# Update number of Radio interfaces created
if [ -e "$FAPI_RPC" ]
then
	num=0
	[ "$name_radio_24" != "EMPTY" ] && num=$((num+1))
	[ "$name_radio_51" != "EMPTY" ] && num=$((num+1))
	[ "$name_radio_52" != "EMPTY" ] && num=$((num+1))
	update_conf_out "Object_${wifi_index}" "$WIFI_OBJECT"
	update_conf_out "RadioNumberOfEntries_${wifi_index}" "$num"
else
	update_conf_out "Object_${wifi_index}" "$WIFI_OBJECT"
	update_conf_out "RadioNumberOfEntries_${wifi_index}" "3"
fi

# Read country from EEPROM - TBD - country was removed from eeprom - need to check.
country_code=`iw wlan0 iwlwav gEEPROM`
country_code=`echo "$eeprom" | sed -n '/EEPROM country:/{s/EEPROM country:.*\([A-Z?][A-Z?]\)/\1/p}'`

# Update the names and status of the interfaces created
# 2.4Ghz Radio
if [ -e "$FAPI_RPC" ] && [ "$name_radio_24" != "EMPTY" ] || [ ! -e "$FAPI_RPC" ]
then
	update_conf_out "Object_${radio_index}" "${RADIO_OBJECT}${radio_index}"
	update_conf_out "Name_${radio_index}" "$name_radio_24"
	update_conf_out "OperatingFrequencyBand_${radio_index}" "2.4GHz"
	update_conf_out "Status_${radio_index}" "$status_radio_24"
	[ -n "$country_code" ] && [ "$country_code" != "??" ] && update_conf_out "RegulatoryDomain_${radio_index}" "$country_code"
fi

# 5Ghz first Radio
radio_index=$next_object_index
next_object_index=$((next_object_index+1))
if [ -e "$FAPI_RPC" ] && [ "$name_radio_51" != "EMPTY" ]  || [ ! -e "$FAPI_RPC" ]
then
	update_conf_out "Object_${radio_index}" "${RADIO_OBJECT}${radio_index}"
	update_conf_out "Name_${radio_index}" "$name_radio_51"
	update_conf_out "OperatingFrequencyBand_${radio_index}" "5GHz"
	update_conf_out "Status_${radio_index}" "$status_radio_51"
	[ -n "$country_code" ] && [ "$country_code" != "??" ] && update_conf_out "RegulatoryDomain_${radio_index}" "$country_code"
fi

# 5Ghz second Radio
radio_index=$next_object_index
next_object_index=$((next_object_index+1))
if [ -e "$FAPI_RPC" ] && [ "$name_radio_52" != "EMPTY" ] || [ ! -e "$FAPI_RPC" ]
then
	update_conf_out "Object_${radio_index}" "${RADIO_OBJECT}${radio_index}"
	update_conf_out "Name_${radio_index}" "$name_radio_52"
	update_conf_out "OperatingFrequencyBand_${radio_index}" "5GHz"
	update_conf_out "Status_${radio_index}" "$status_radio_52"
	[ -n "$country_code" ] && [ "$country_code" != "??" ] && update_conf_out "RegulatoryDomain_${radio_index}" "$country_code"
fi

# 2.4GHz AP SSID
ssid_index=$next_object_index
next_object_index=$((next_object_index+1))
update_conf_out "Object_${ssid_index}" "${SSID_OBJECT}${ssid_index}"
update_conf_out "Name_${ssid_index}" "$name_radio_24"

# 5GHz first AP SSID
ssid_index=$next_object_index
next_object_index=$((next_object_index+1))
update_conf_out "Object_${ssid_index}" "${SSID_OBJECT}${ssid_index}"
update_conf_out "Name_${ssid_index}" "$name_radio_51"

# 5GHz second AP SSID
ssid_index=$next_object_index
next_object_index=$((next_object_index+1))
update_conf_out "Object_${ssid_index}" "${SSID_OBJECT}${ssid_index}"
update_conf_out "Name_${ssid_index}" "$name_radio_52"

# 2.4GHz EndPoint SSID
ssid_index=$next_object_index
next_object_index=$((next_object_index+1))
update_conf_out "Object_${ssid_index}" "${SSID_OBJECT}${ssid_index}"
update_conf_out "Name_${ssid_index}" "$name_sta_24"

# 5GHz first EndPoint SSID
ssid_index=$next_object_index
next_object_index=$((next_object_index+1))
update_conf_out "Object_${ssid_index}" "${SSID_OBJECT}${ssid_index}"
update_conf_out "Name_${ssid_index}" "$name_sta_51"

# 5GHz second EndPoint SSID
ssid_index=$next_object_index
next_object_index=$((next_object_index+1))
update_conf_out "Object_${ssid_index}" "${SSID_OBJECT}${ssid_index}"
update_conf_out "Name_${ssid_index}" "$name_sta_52"

# Update indexes used in the DB for each radio and STA (number of STA is same as number of radios)
if [ ! -e $INTERFACES_INDEXES ]
then
	next_interface_index=0
	[ -n "$name_radio_24" ] && echo "${name_radio_24}_index=$next_interface_index" >> $INTERFACES_INDEXES && next_interface_index=$((next_interface_index+1))
	[ -n "$name_sta_24" ] && echo "${name_sta_24}_index=$next_interface_index" >> $INTERFACES_INDEXES && next_interface_index=$((next_interface_index+1))
	[ -n "$name_radio_51" ] && echo "${name_radio_51}_index=$next_interface_index" >> $INTERFACES_INDEXES && next_interface_index=$((next_interface_index+1))
	[ -n "$name_sta_51" ] && echo "${name_sta_51}_index=$next_interface_index" >> $INTERFACES_INDEXES && next_interface_index=$((next_interface_index+1))
	[ -n "$name_radio_52" ] && echo "${name_radio_52}_index=$next_interface_index" >> $INTERFACES_INDEXES && next_interface_index=$((next_interface_index+1))
	[ -n "$name_sta_52" ] && echo "${name_sta_52}_index=$next_interface_index" >> $INTERFACES_INDEXES && next_interface_index=$((next_interface_index+1))
	echo "next_interface_index=$next_interface_index" >> $INTERFACES_INDEXES
fi

# Configuration is completed successfully
update_conf_out "wlan_configuration_status" "success"

# Save the out.conf file to be used after reboot
cp ${OUT_CONF} ${HW_INIT_OUT_CONF}

# DEBUG: set debug_save_conf in fapi_wlan_wave_lib_common.sh to save the out conf file
[ "$debug_save_conf" ] && cp ${OUT_CONF} ${TEMP_DIR}/hw_init_out_conf

print2log $radio0_vendor_index DEBUG "$script_name done"
timestamp $radio0_vendor_index "$script_name:done"

#!/bin/sh
#
# nat.sh  This script go for starting/stop NAT/QoS services using iptables
#

# Paths to programs
UVM=/usr/bin/uvm
UO_PATH=/usr/uo/
#UO_PATH=/tmp/uo/
NAT_PATH=/var/nat/
WAN=""
FUNC=""

## All Basic iptables functions are in nat-draft
NATD=nat-draft
ADJ_KNL=adjust-kernel
DM_FLTR=domain-filter
MAC_CTL=mac-control
PORT_FWD=port-forwarding
PK_FLTR=pkt-filter
PK_FLTR_V6=pkt-filterv6
PK_FLTR_DDC=pkt-filter-ddc
RATECTL=rate-control
QOSPKT=qos-smallpkt
STEALTH=stealth-mode
URL_BLK=url-block
VCOMP=virtual-computer
PROXY=proxy

check_hw_nat()
{
    if [ "`rdcsman 0x00010233 u8`" -eq 0 ]; then #enable hw nat
        if [ -z "`lsmod | grep hw_nat`" ]; then
            modprobe hw_nat
        fi
    else
        if [ ! -z "`lsmod | grep hw_nat`" ]; then
            rmmod -f hw_nat
        fi
    fi
}

start() 
{
    check_hw_nat;
    mkdir -p $NAT_PATH
    rm -f $NAT_PATH/*.uyg

    echo "==== NAT START (WAN:$WAN Func:$FUNC) ===="
    [ -e $UO_PATH/$NATD.uyg.uo     ]    && $UVM -m 740 -o $NAT_PATH/$NATD.uyg     $UO_PATH/$NATD.uyg.uo
    [ -e $UO_PATH/$ADJ_KNL.uyg.uo  ]    && $UVM -m 740 -o $NAT_PATH/$ADJ_KNL.uyg  $UO_PATH/$ADJ_KNL.uyg.uo
    [ -e $UO_PATH/$PK_FLTR.uyg.uo  ]    && $UVM -m 740 -o $NAT_PATH/$PK_FLTR.uyg  $UO_PATH/$PK_FLTR.uyg.uo
    [ -e $UO_PATH/$PK_FLTR_DDC.uyg.uo ] && $UVM -m 740 -o $NAT_PATH/$PK_FLTR_DDC.uyg  $UO_PATH/$PK_FLTR_DDC.uyg.uo
    [ -e $UO_PATH/$DM_FLTR.uyg.uo  ]    && $UVM -m 740 -o $NAT_PATH/$DM_FLTR.uyg  $UO_PATH/$DM_FLTR.uyg.uo
    [ -e $UO_PATH/$URL_BLK.uyg.uo  ]    && $UVM -m 740 -o $NAT_PATH/$URL_BLK.uyg  $UO_PATH/$URL_BLK.uyg.uo
    [ -e $UO_PATH/$MAC_CTL.uyg.uo  ]    && $UVM -m 740 -o $NAT_PATH/$MAC_CTL.uyg  $UO_PATH/$MAC_CTL.uyg.uo
    [ -e $UO_PATH/$PORT_FWD.uyg.uo ]    && $UVM -m 740 -o $NAT_PATH/$PORT_FWD.uyg $UO_PATH/$PORT_FWD.uyg.uo
    [ -e $UO_PATH/$VCOMP.uyg.uo    ]    && $UVM -m 740 -o $NAT_PATH/$VCOMP.uyg    $UO_PATH/$VCOMP.uyg.uo
    [ -e $UO_PATH/$PROXY.uyg.uo    ]    && $UVM -m 740 -o $NAT_PATH/$PROXY.uyg    $UO_PATH/$PROXY.uyg.uo
    [ -e $UO_PATH/$RATECTL.uyg.uo  ]    && $UVM -m 740 -o $NAT_PATH/$RATECTL.uyg  $UO_PATH/$RATECTL.uyg.uo
    [ -e $UO_PATH/$QOSPKT.uyg.uo   ]    && $UVM -m 740 -o $NAT_PATH/$QOSPKT.uyg   $UO_PATH/$QOSPKT.uyg.uo
    [ -e $UO_PATH/$STEALTH.uyg.uo  ]    && $UVM -m 740 -o $NAT_PATH/$STEALTH.uyg  $UO_PATH/$STEALTH.uyg.uo
    [ -e $UO_PATH/$PK_FLTR_V6.uyg.uo ]  && $UVM -m 740 -o $NAT_PATH/$PK_FLTR_V6.uyg  $UO_PATH/$PK_FLTR_V6.uyg.uo
    
    for FUNC_ in `echo $FUNC |awk '{for(i=1;i<=split($0,r,"+");i++)printf("%s ", r[i]);}'` ; do
        $NAT_PATH/$NATD.uyg "start" "$WAN" "$FUNC_"
    done
 
}

reset_icmp() 
{
    echo "==== Reset ICMP Timeout ===="
    local PROC_ICMP_TIMEO="/proc/sys/net/ipv4/netfilter/ip_conntrack_icmp_timeout";
    local ICMP_TIMEO_SH="/tmp/reset-timeout";
    local ICMP_TIMEO_PID="/tmp/reset-timeout.pid";
    local init_value="0"
    [ "$1" != "" ] && init_value="$1"

    # kill previous reset-timeout
    rm -f $ICMP_TIMEO_SH
    if [ -e $ICMP_TIMEO_PID ]; then
        kill `cat $ICMP_TIMEO_PID`
        rm -f $ICMP_TIMEO_PID
    fi   

    echo "
        #iptables -t nat -I PREROUTING -p icmp -i br0 -d ! $LAN_IP_RANGE -j DROP 

        local time=1
        local value=$init_value
        while [ true ]; do 
            [ ! -e $ICMP_TIMEO_SH ] && break

            echo \$value > $PROC_ICMP_TIMEO
            [ \$time -ge 15 ] && value=\$((value+1))
            [ \$time -ge 45 ] && break

            time=\$((time+1))
            sleep 1
        done     

        echo 30 > $PROC_ICMP_TIMEO
        #iptables -t nat -D PREROUTING -p icmp -i br0 -d ! $LAN_IP_RANGE -j DROP
        rm -f $ICMP_TIMEO_SH
    " >> $ICMP_TIMEO_SH;

    sh $ICMP_TIMEO_SH &
    echo $! > $ICMP_TIMEO_PID   
}

stop() 
{
	echo "=== NAT STOP (WAN:$WAN Func:$FUNC) ===="
    for FUNC_ in `echo $FUNC |awk '{for(i=1;i<=split($0,r,"+");i++)printf("%s ", r[i]);}'` ; do
        $NAT_PATH/$NATD.uyg "stop" "$WAN" "$FUNC_" 
    done
}

usage() 
{
	echo "AmitNATServ Usage: $0 [action] [wan] [options]"
	echo "action:"
	echo "  start/stop/restart"
	echo ""
    echo "wan:"
    echo "  wanx/wan1/wan2/..."
    echo ""
	echo "options:"
	echo "  mactl       : MAC Control"
	echo "  urlblk      : URL Blocking"
	echo "  urlblkfileext : URL File Extension Blocking"
	echo "  dmfilter    : Domain Filter"
	echo "  pktfilter   : Packet Filter"
	echo "  portfwd     : Port Forward"
	echo "  portopen    : Open Port"
	echo "  vcomp       : Virtual Computer"
	echo "  proxy       : Proxy Client"
	echo "  ratectl     : Rate Controller"
	echo "  stealth     : Stealth Mode"
	echo "  qospkt      : QoS for small size packets (NO support Multi WAN strt/stop/restrt)"
	echo "  admin       : Remote Admin"
	echo "  webhdd      : Web HDD"
	echo "  shareport   : SharePort"
	echo "  mydlink     : My D-Link"
	echo "  dmz         : DMZ"
	echo "  spi         : SPI Mode"
	echo "  blkicmp     : Block ICMP from WAN (NO support Multi WAN strt/stop/restrt)"
	echo "  blkwan      : Block Packets from WAN (NO support Multi WAN strt/stop/restrt)"
	echo "  adjmss      : Adjust MSS (NO support Multi WAN strt/stop/restrt)"
	echo "  masq        : Masquerade "
	echo "  upnp        : UPnP"
	echo "  mupnpd      : Mini-UPnP"
	echo "  alg         : PPTP/L2TP/IPsec Passthrough"
	echo "  mwbif       : Some Services need bind IF. when Multi WAN (NO support Multi WAN strt/stop/restrt)"
	echo "  loopback    : NAT Loopback"
	echo "  reset-icmp  : Reset ICMP conntrack timeout"
	echo "  pktfilterv6 : IPv6 Packet Filter"
	echo "  guestzone   : Guest Zone"
	echo "  ipsec       : Do Masq. for Netkey-IPSec Tunnels"
	echo ""
	exit 1
}

show()
{
    local cmd="$1"
    local sub_cmd="$2"
    if [ "$cmd" = "" ]; then
        echo "Usage: "
        echo "  nat show [filter|nat|mangle] [list] "
        echo "  nat show [tc] [wan_if] "
        echo ""
    elif [ "`expr substr $cmd 1 1`" = "t" ]; then
        if [ "$sub_cmd" != "" ]; then
            tc qdisc show dev $sub_cmd
        else
            tc qdisc show
        fi
    elif [ "`expr substr $cmd 1 1`" = "f" ]; then
        if [ "$sub_cmd" != "" ]; then
            iptables --list-rules
        else
            iptables -L -nv 
        fi
    elif [ "`expr substr $cmd 1 1`" = "n" ]; then
        if [ "$sub_cmd" != "" ]; then
            iptables -t nat --list-rules
        else        
            iptables -t nat -L -nv
        fi
    elif [ "`expr substr $cmd 1 1`" = "m" ]; then
        if [ "$sub_cmd" != "" ]; then
            iptables -t mangle --list-rules
        else             
            iptables -t mangle -L -nv
        fi
    else 
        echo "Usage: "
        echo "  nat show [filter|nat|mangle] [list] "
        echo "  nat show [tc] [wan_if] "
        echo ""
    fi
    exit 0
}

# +++++++++++++++ main ++++++++++++++++++++++ 
[ "$1" = "" ] && usage
[ "$1" = "show" ] && show "$2" "$3"

if [ "$2" = "" ]; then
    WAN="ALL"
elif [ "$2" = "wanx" ] || [ "$2" = "ALL" ]; then
    WAN="ALL"
elif [ "$2" = "wan1" ] || [ "$2" = "wan2" ]; then
    WAN="$2"
elif [ "$1" = "reset-icmp" ]; then
    reset_icmp "$2"
    exit 0
else 
    usage
fi

if [ "$3" = "" ]; then
    FUNC="ALL"
elif [ "$3" = "misc" ]; then # special case, don't recommand to use
    nat "$1" "$WAN" "admin   + webhdd  + \
                     stealth + proxy   + qospkt   + \
                     ratectl + upnp     + \ 
                     mupnpd  + alg     + loopback + \
                     shareport + mydlink + spi + dmz "
    exit 0
else
    FUNC="$3"
fi

case "$1" in
	"init")	      start ;;
	"start")	  start ;;
	"stop")		  stop  ;;
	"restart")	  start ;;
	"reset-icmp") reset_icmp ;;
	*)		      usage ;;
esac
exit 0

